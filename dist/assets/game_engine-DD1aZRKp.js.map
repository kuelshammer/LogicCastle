{"version":3,"file":"game_engine-DD1aZRKp.js","sources":["../../game_engine/pkg/game_engine.js"],"sourcesContent":["let wasm;\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_export_0(addHeapObject(e));\n    }\n}\n\nconst cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );\n\nif (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); };\n\nlet cachedUint8ArrayMemory0 = null;\n\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n}\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst cachedTextEncoder = (typeof TextEncoder !== 'undefined' ? new TextEncoder('utf-8') : { encode: () => { throw Error('TextEncoder not available') } } );\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n\n    const mem = getUint8ArrayMemory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n        ptr = realloc(ptr, len, offset, 1) >>> 0;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nlet cachedDataViewMemory0 = null;\n\nfunction getDataViewMemory0() {\n    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer)) {\n        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);\n    }\n    return cachedDataViewMemory0;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nlet cachedUint32ArrayMemory0 = null;\n\nfunction getUint32ArrayMemory0() {\n    if (cachedUint32ArrayMemory0 === null || cachedUint32ArrayMemory0.byteLength === 0) {\n        cachedUint32ArrayMemory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachedUint32ArrayMemory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint32ArrayMemory0().subarray(ptr / 4, ptr / 4 + len);\n}\n/**\n * Helper function to convert difficulty string to number\n * @param {string} difficulty\n * @returns {number}\n */\nexport function difficulty_to_number(difficulty) {\n    const ptr0 = passStringToWasm0(difficulty, wasm.__wbindgen_export_2, wasm.__wbindgen_export_3);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.difficulty_to_number(ptr0, len0);\n    return ret;\n}\n\n/**\n * Helper function to convert difficulty number to string\n * @param {number} difficulty\n * @returns {string}\n */\nexport function difficulty_to_string(difficulty) {\n    let deferred1_0;\n    let deferred1_1;\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.difficulty_to_string(retptr, difficulty);\n        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n        deferred1_0 = r0;\n        deferred1_1 = r1;\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_export_1(deferred1_0, deferred1_1, 1);\n    }\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n}\n\nexport function main() {\n    wasm.main();\n}\n\nlet cachedInt8ArrayMemory0 = null;\n\nfunction getInt8ArrayMemory0() {\n    if (cachedInt8ArrayMemory0 === null || cachedInt8ArrayMemory0.byteLength === 0) {\n        cachedInt8ArrayMemory0 = new Int8Array(wasm.memory.buffer);\n    }\n    return cachedInt8ArrayMemory0;\n}\n\nfunction getArrayI8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getInt8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nlet cachedInt16ArrayMemory0 = null;\n\nfunction getInt16ArrayMemory0() {\n    if (cachedInt16ArrayMemory0 === null || cachedInt16ArrayMemory0.byteLength === 0) {\n        cachedInt16ArrayMemory0 = new Int16Array(wasm.memory.buffer);\n    }\n    return cachedInt16ArrayMemory0;\n}\n\nfunction getArrayI16FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getInt16ArrayMemory0().subarray(ptr / 2, ptr / 2 + len);\n}\n\nfunction getArrayJsValueFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    const mem = getDataViewMemory0();\n    const result = [];\n    for (let i = ptr; i < ptr + 4 * len; i += 4) {\n        result.push(takeObject(mem.getUint32(i, true)));\n    }\n    return result;\n}\n/**\n * AI Difficulty levels with variable Stage 4 strategies\n * All difficulties use Stage 1-3 (Win/Block/Safe), but differ in Stage 4\n * @enum {0 | 1 | 2}\n */\nexport const AIDifficulty = Object.freeze({\n    Easy: 0, \"0\": \"Easy\",\n    Medium: 1, \"1\": \"Medium\",\n    Hard: 2, \"2\": \"Hard\",\n});\n/**\n * @enum {0 | 1 | 2 | 3 | 4 | 5}\n */\nexport const GameError = Object.freeze({\n    OutOfBounds: 0, \"0\": \"OutOfBounds\",\n    PositionOccupied: 1, \"1\": \"PositionOccupied\",\n    GameAlreadyOver: 2, \"2\": \"GameAlreadyOver\",\n    InvalidPlayer: 3, \"3\": \"InvalidPlayer\",\n    BoardError: 4, \"4\": \"BoardError\",\n    InvalidMove: 5, \"5\": \"InvalidMove\",\n});\n/**\n * Game phase enumeration for strategic evaluation\n * @enum {0 | 1 | 2}\n */\nexport const GamePhase = Object.freeze({\n    Opening: 0, \"0\": \"Opening\",\n    Middle: 1, \"1\": \"Middle\",\n    Endgame: 2, \"2\": \"Endgame\",\n});\n/**\n * @enum {1 | 2 | 3 | 4}\n */\nexport const Player = Object.freeze({\n    Yellow: 1, \"1\": \"Yellow\",\n    Red: 2, \"2\": \"Red\",\n    Black: 3, \"3\": \"Black\",\n    White: 4, \"4\": \"White\",\n});\n/**\n * @enum {0 | 1 | 2 | 3 | 4}\n */\nexport const TrioDifficulty = Object.freeze({\n    Impossible: 0, \"0\": \"Impossible\",\n    Hard: 1, \"1\": \"Hard\",\n    Medium: 2, \"2\": \"Medium\",\n    Easy: 3, \"3\": \"Easy\",\n    VeryEasy: 4, \"4\": \"VeryEasy\",\n});\n/**\n * Difficulty levels for board generation\n * @enum {1 | 2 | 3 | 4}\n */\nexport const TrioDifficultyNew = Object.freeze({\n    Kinderfreundlich: 1, \"1\": \"Kinderfreundlich\",\n    Vollspektrum: 2, \"2\": \"Vollspektrum\",\n    Strategisch: 3, \"3\": \"Strategisch\",\n    Analytisch: 4, \"4\": \"Analytisch\",\n});\n/**\n * @enum {0 | 1 | 2 | 3}\n */\nexport const TrioDistribution = Object.freeze({\n    Balanced: 0, \"0\": \"Balanced\",\n    Educational: 1, \"1\": \"Educational\",\n    Challenging: 2, \"2\": \"Challenging\",\n    Official: 3, \"3\": \"Official\",\n});\n\nconst AiMoveFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_aimove_free(ptr >>> 0, 1));\n/**\n * A struct to represent an AI move for wasm-bindgen.\n */\nexport class AiMove {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(AiMove.prototype);\n        obj.__wbg_ptr = ptr;\n        AiMoveFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AiMoveFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_aimove_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    get row() {\n        const ret = wasm.__wbg_get_aimove_row(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} arg0\n     */\n    set row(arg0) {\n        wasm.__wbg_set_aimove_row(this.__wbg_ptr, arg0);\n    }\n    /**\n     * @returns {number}\n     */\n    get col() {\n        const ret = wasm.__wbg_get_aimove_col(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} arg0\n     */\n    set col(arg0) {\n        wasm.__wbg_set_aimove_col(this.__wbg_ptr, arg0);\n    }\n}\n\nconst BoardFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_board_free(ptr >>> 0, 1));\n\nexport class Board {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Board.prototype);\n        obj.__wbg_ptr = ptr;\n        BoardFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        BoardFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_board_free(ptr, 0);\n    }\n    /**\n     * @param {number} rows\n     * @param {number} cols\n     */\n    constructor(rows, cols) {\n        const ret = wasm.board_new(rows, cols);\n        this.__wbg_ptr = ret >>> 0;\n        BoardFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {number}\n     */\n    get_rows() {\n        const ret = wasm.board_get_rows(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get_cols() {\n        const ret = wasm.board_get_cols(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {Int8Array}\n     */\n    get_cells() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.board_get_cells(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayI8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} row\n     * @param {number} col\n     * @returns {number}\n     */\n    get_cell(row, col) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.board_get_cell(retptr, this.__wbg_ptr, row, col);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} row\n     * @param {number} col\n     * @param {number} value\n     */\n    set_cell(row, col, value) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.board_set_cell(retptr, this.__wbg_ptr, row, col, value);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} row\n     * @param {number} col\n     * @returns {boolean}\n     */\n    is_within_bounds(row, col) {\n        const ret = wasm.board_is_within_bounds(this.__wbg_ptr, row, col);\n        return ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    is_full() {\n        const ret = wasm.board_is_full(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Check if a column is full (Connect4) - memory efficient check\n     * @param {number} col\n     * @returns {boolean}\n     */\n    is_column_full(col) {\n        const ret = wasm.board_is_column_full(this.__wbg_ptr, col);\n        return ret !== 0;\n    }\n    /**\n     * Get column height (Connect4) - essential for AI move generation\n     * @param {number} col\n     * @returns {number}\n     */\n    column_height(col) {\n        const ret = wasm.board_column_height(this.__wbg_ptr, col);\n        return ret >>> 0;\n    }\n    /**\n     * Fast clone for AI simulations - reuses memory layout\n     * @returns {Board}\n     */\n    fast_clone() {\n        const ret = wasm.board_fast_clone(this.__wbg_ptr);\n        return Board.__wrap(ret);\n    }\n    /**\n     * Check if a specific column has available space (for Connect4)\n     * @param {number} col\n     * @returns {boolean}\n     */\n    is_column_available(col) {\n        const ret = wasm.board_is_column_available(this.__wbg_ptr, col);\n        return ret !== 0;\n    }\n    /**\n     * Get the row where a piece would land in a column (for Connect4)\n     * @param {number} col\n     * @returns {number | undefined}\n     */\n    get_drop_row(col) {\n        const ret = wasm.board_get_drop_row(this.__wbg_ptr, col);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n}\n\nconst Connect4AIFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_connect4ai_free(ptr >>> 0, 1));\n/**\n * Connect4 AI implementation using Gemini's pattern-based evaluation\n * Implements the \"Stratege\" layer of the Three-Layer Architecture\n */\nexport class Connect4AI {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Connect4AI.prototype);\n        obj.__wbg_ptr = ptr;\n        Connect4AIFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        Connect4AIFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_connect4ai_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.connect4ai_new();\n        this.__wbg_ptr = ret >>> 0;\n        Connect4AIFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Create AI with specific difficulty level\n     * @param {AIDifficulty} difficulty\n     * @returns {Connect4AI}\n     */\n    static with_difficulty(difficulty) {\n        const ret = wasm.connect4ai_with_difficulty(difficulty);\n        return Connect4AI.__wrap(ret);\n    }\n    /**\n     * Set the AI player (default: Red)\n     * @param {Player} player\n     */\n    set_ai_player(player) {\n        wasm.connect4ai_set_ai_player(this.__wbg_ptr, player);\n    }\n    /**\n     * Set search depth (higher = stronger but slower)\n     * @param {number} depth\n     */\n    set_difficulty(depth) {\n        wasm.connect4ai_set_difficulty(this.__wbg_ptr, depth);\n    }\n    /**\n     * Set AI difficulty level (Easy/Medium/Hard)\n     * This is the preferred way to set AI strength\n     * @param {AIDifficulty} difficulty\n     */\n    set_difficulty_level(difficulty) {\n        wasm.connect4ai_set_difficulty_level(this.__wbg_ptr, difficulty);\n    }\n    /**\n     * Get current difficulty level\n     * @returns {AIDifficulty}\n     */\n    get_difficulty_level() {\n        const ret = wasm.connect4ai_get_difficulty_level(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get the best move for the current position\n     * @param {Connect4Game} game\n     * @returns {number | undefined}\n     */\n    get_best_move(game) {\n        _assertClass(game, Connect4Game);\n        const ret = wasm.connect4ai_get_best_move(this.__wbg_ptr, game.__wbg_ptr);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * Get the best move for a specific player (bidirectional AI)\n     * This allows the AI to predict moves for both players\n     * Unlike get_best_move, this works regardless of whose turn it is\n     * @param {Connect4Game} game\n     * @param {Player} player\n     * @returns {number | undefined}\n     */\n    get_best_move_for_player(game, player) {\n        _assertClass(game, Connect4Game);\n        const ret = wasm.connect4ai_get_best_move_for_player(this.__wbg_ptr, game.__wbg_ptr, player);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * Get the evaluation score for the current position\n     * @param {Connect4Game} game\n     * @returns {number}\n     */\n    evaluate_position(game) {\n        _assertClass(game, Connect4Game);\n        const ret = wasm.connect4ai_evaluate_position(this.__wbg_ptr, game.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get a quick move for time-constrained situations\n     * @param {Connect4Game} game\n     * @returns {number | undefined}\n     */\n    get_quick_move(game) {\n        _assertClass(game, Connect4Game);\n        const ret = wasm.connect4ai_get_quick_move(this.__wbg_ptr, game.__wbg_ptr);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n}\n\nconst Connect4GameFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_connect4game_free(ptr >>> 0, 1));\n/**\n * Connect4 game implementation using the Three-Layer Architecture\n * Composes geometry and data layers for clean separation of concerns\n */\nexport class Connect4Game {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Connect4Game.prototype);\n        obj.__wbg_ptr = ptr;\n        Connect4GameFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        Connect4GameFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_connect4game_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.connect4game_new();\n        this.__wbg_ptr = ret >>> 0;\n        Connect4GameFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Create a new Connect4 game with a specific starting player\n     * This is essential for game series where \"loser starts next game\"\n     * @param {Player} starting_player\n     * @returns {Connect4Game}\n     */\n    static new_with_starting_player(starting_player) {\n        const ret = wasm.connect4game_new_with_starting_player(starting_player);\n        return Connect4Game.__wrap(ret);\n    }\n    /**\n     * Make a move in the specified column\n     * @param {number} column\n     * @returns {boolean}\n     */\n    make_move(column) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.connect4game_make_move(retptr, this.__wbg_ptr, column);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0 !== 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get cell value at position (0 = empty, 1 = yellow, 2 = red)\n     * @param {number} row\n     * @param {number} col\n     * @returns {number}\n     */\n    get_cell(row, col) {\n        const ret = wasm.connect4game_get_cell(this.__wbg_ptr, row, col);\n        return ret;\n    }\n    /**\n     * Get current player\n     * @returns {Player}\n     */\n    current_player() {\n        const ret = wasm.connect4game_current_player(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get winner (if any)\n     * @returns {Player | undefined}\n     */\n    winner() {\n        const ret = wasm.connect4game_get_winner(this.__wbg_ptr);\n        return ret === 0 ? undefined : ret;\n    }\n    /**\n     * Get move count\n     * @returns {number}\n     */\n    move_count() {\n        const ret = wasm.connect4game_get_move_count(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Check if column is valid for next move\n     * @param {number} column\n     * @returns {boolean}\n     */\n    is_valid_move(column) {\n        const ret = wasm.connect4game_is_valid_move(this.__wbg_ptr, column);\n        return ret !== 0;\n    }\n    /**\n     * Get column height\n     * @param {number} column\n     * @returns {number}\n     */\n    get_column_height(column) {\n        const ret = wasm.connect4game_get_column_height(this.__wbg_ptr, column);\n        return ret >>> 0;\n    }\n    /**\n     * Reset game to initial state\n     */\n    reset() {\n        wasm.connect4game_newGame(this.__wbg_ptr);\n    }\n    /**\n     * Reset game with a specific starting player\n     * @param {Player} starting_player\n     */\n    reset_with_starting_player(starting_player) {\n        wasm.connect4game_reset_with_starting_player(this.__wbg_ptr, starting_player);\n    }\n    /**\n     * Start a new game series with \"loser starts\" rule (legacy method)\n     * If loser_starts is true, the losing player from the previous game starts the next game\n     * @param {boolean} loser_starts\n     */\n    start_new_series(loser_starts) {\n        wasm.connect4game_start_new_series(this.__wbg_ptr, loser_starts);\n    }\n    /**\n     * Start a new game series with fixed player colors\n     * Players keep their colors throughout the series, only start order changes\n     * This is ideal for tournaments where Player A = always Yellow, Player B = always Red\n     * @param {Player} player_a\n     * @param {Player} player_b\n     * @param {Player} winner\n     */\n    start_new_series_with_players(player_a, player_b, winner) {\n        wasm.connect4game_start_new_series_with_players(this.__wbg_ptr, player_a, player_b, winner);\n    }\n    /**\n     * Create a hypothetical game state for AI evaluation\n     * This allows the AI to evaluate positions regardless of whose turn it is\n     * @param {Player} hypothetical_player\n     * @returns {Connect4Game}\n     */\n    create_hypothetical_state(hypothetical_player) {\n        const ret = wasm.connect4game_create_hypothetical_state(this.__wbg_ptr, hypothetical_player);\n        return Connect4Game.__wrap(ret);\n    }\n    /**\n     * Get board state as string for debugging\n     * @returns {string}\n     */\n    board_string() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.connect4game_board_string(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_1(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Check if game is draw (board full, no winner)\n     * @returns {boolean}\n     */\n    is_draw() {\n        const ret = wasm.connect4game_is_draw(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Check if game is over (win or draw)\n     * @returns {boolean}\n     */\n    is_game_over() {\n        const ret = wasm.connect4game_is_game_over(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Get AI move suggestion using BULLETPROOF 4-stage hierarchical decision logic\n     * ABSOLUTE PRIORITY: Own win > Block opponent > Strategic play\n     * @returns {number | undefined}\n     */\n    get_ai_move() {\n        const ret = wasm.connect4game_getAIMove(this.__wbg_ptr);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * Analyze current position comprehensively\n     * @returns {PositionAnalysis}\n     */\n    analyze_position() {\n        const ret = wasm.connect4game_analyze_position(this.__wbg_ptr);\n        return PositionAnalysis.__wrap(ret);\n    }\n    /**\n     * Get current game phase for AI strategy\n     * @returns {GamePhase}\n     */\n    get_game_phase() {\n        const ret = wasm.connect4game_get_game_phase(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get memory usage of the game state (for performance monitoring)\n     * @returns {number}\n     */\n    memory_usage() {\n        const ret = wasm.connect4game_memory_usage(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Get current player (frontend naming convention)\n     * @returns {Player}\n     */\n    get_current_player() {\n        const ret = wasm.connect4game_current_player(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Set AI difficulty level\n     * @param {AIDifficulty} difficulty\n     */\n    set_ai_difficulty(difficulty) {\n        wasm.connect4game_set_ai_difficulty(this.__wbg_ptr, difficulty);\n    }\n    /**\n     * Get current AI difficulty level\n     * @returns {AIDifficulty}\n     */\n    get_ai_difficulty() {\n        const ret = wasm.connect4game_get_ai_difficulty(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get move count (frontend naming convention)\n     * @returns {number}\n     */\n    get_move_count() {\n        const ret = wasm.connect4game_get_move_count(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Get winner (frontend naming convention)\n     * @returns {Player | undefined}\n     */\n    get_winner() {\n        const ret = wasm.connect4game_get_winner(this.__wbg_ptr);\n        return ret === 0 ? undefined : ret;\n    }\n    /**\n     * Get board state as flat array for frontend (6 rows × 7 cols = 42 elements)\n     * @returns {Uint8Array}\n     */\n    get_board() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.connect4game_get_board(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Check if undo is possible\n     * @returns {boolean}\n     */\n    can_undo() {\n        const ret = wasm.connect4game_can_undo(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Undo the last move\n     * @returns {boolean}\n     */\n    undo_move() {\n        const ret = wasm.connect4game_undo_move(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Get AI board representation (for assistance system)\n     * @returns {Uint8Array}\n     */\n    get_ai_board() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.connect4game_get_ai_board(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get threatening moves for a player\n     * @param {Player} player\n     * @returns {Uint32Array}\n     */\n    get_threatening_moves(player) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.connect4game_get_threatening_moves(retptr, this.__wbg_ptr, player);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get winning moves for a player\n     * @param {Player} player\n     * @returns {Uint32Array}\n     */\n    get_winning_moves(player) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.connect4game_get_winning_moves(retptr, this.__wbg_ptr, player);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get blocking moves (moves that prevent opponent from winning)\n     * @param {Player} player\n     * @returns {Uint32Array}\n     */\n    get_blocking_moves(player) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.connect4game_get_blocking_moves(retptr, this.__wbg_ptr, player);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Evaluate position for a specific player\n     * @param {Player} player\n     * @returns {number}\n     */\n    evaluate_position_for_player(player) {\n        const ret = wasm.connect4game_evaluate_position_for_player(this.__wbg_ptr, player);\n        return ret;\n    }\n    /**\n     * Frontend-friendly method aliases\n     */\n    newGame() {\n        wasm.connect4game_newGame(this.__wbg_ptr);\n    }\n    /**\n     * @returns {boolean}\n     */\n    undoMove() {\n        const ret = wasm.connect4game_undoMove(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {number | undefined}\n     */\n    getAIMove() {\n        const ret = wasm.connect4game_getAIMove(this.__wbg_ptr);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n}\n\nconst GameFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_game_free(ptr >>> 0, 1));\n\nexport class Game {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Game.prototype);\n        obj.__wbg_ptr = ptr;\n        GameFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        GameFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_game_free(ptr, 0);\n    }\n    /**\n     * @param {number} rows\n     * @param {number} cols\n     * @param {number} win_condition\n     * @param {boolean} gravity_enabled\n     */\n    constructor(rows, cols, win_condition, gravity_enabled) {\n        const ret = wasm.game_new(rows, cols, win_condition, gravity_enabled);\n        this.__wbg_ptr = ret >>> 0;\n        GameFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {number} col\n     */\n    make_move_connect4_js(col) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.game_make_move_connect4_js(retptr, this.__wbg_ptr, col);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} row\n     * @param {number} col\n     */\n    make_move_gobang_js(row, col) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.game_make_move_gobang_js(retptr, this.__wbg_ptr, row, col);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Player | undefined}\n     */\n    check_win() {\n        const ret = wasm.game_check_win(this.__wbg_ptr);\n        return ret === 0 ? undefined : ret;\n    }\n    /**\n     * @returns {boolean}\n     */\n    is_game_over() {\n        const ret = wasm.game_is_game_over(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {Int8Array}\n     */\n    get_board() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.game_get_board(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayI8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Player}\n     */\n    get_current_player() {\n        const ret = wasm.game_get_current_player(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get the starting player for this game\n     * @returns {Player}\n     */\n    get_starting_player() {\n        const ret = wasm.game_get_starting_player(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Set the starting player (for rotation logic)\n     * @param {Player} player\n     */\n    set_starting_player(player) {\n        wasm.game_set_starting_player(this.__wbg_ptr, player);\n    }\n    /**\n     * Reset game to starting state with optional new starting player\n     */\n    reset_game() {\n        wasm.game_reset_game(this.__wbg_ptr);\n    }\n    /**\n     * Reset game with a specific starting player\n     * @param {Player} starter\n     */\n    reset_game_with_starter(starter) {\n        wasm.game_reset_game_with_starter(this.__wbg_ptr, starter);\n    }\n    /**\n     * Fast clone for AI simulations - essential for minimax/MCTS\n     * @returns {Game}\n     */\n    fast_clone() {\n        const ret = wasm.game_fast_clone(this.__wbg_ptr);\n        return Game.__wrap(ret);\n    }\n    /**\n     * Get legal moves for Connect4 (WASM-friendly, memory efficient)\n     * @returns {Uint32Array}\n     */\n    get_legal_moves_connect4() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.game_get_legal_moves_connect4(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Count legal moves efficiently (for quick AI evaluation)\n     * @returns {number}\n     */\n    legal_move_count_connect4() {\n        const ret = wasm.game_legal_move_count_connect4(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Simulate a move efficiently (for AI tree search)\n     * @param {number} col\n     * @returns {Game}\n     */\n    simulate_move_connect4(col) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.game_simulate_move_connect4(retptr, this.__wbg_ptr, col);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Game.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Simulate a move efficiently (WASM-compatible version)\n     * @param {number} col\n     * @returns {Game | undefined}\n     */\n    simulate_move_connect4_js(col) {\n        const ret = wasm.game_simulate_move_connect4_js(this.__wbg_ptr, col);\n        return ret === 0 ? undefined : Game.__wrap(ret);\n    }\n    /**\n     * Check if game is in terminal state (win/draw)\n     * @returns {boolean}\n     */\n    is_terminal() {\n        const ret = wasm.game_is_game_over(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Advanced position evaluation with strategic scoring\n     * Returns: +10000 for current player win, -10000 for opponent win, strategic score otherwise\n     * @returns {number}\n     */\n    evaluate_position() {\n        const ret = wasm.game_evaluate_position(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Simple evaluation for backward compatibility\n     * @returns {number}\n     */\n    evaluate_position_simple() {\n        const ret = wasm.game_evaluate_position_simple(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Advanced evaluation combining multiple strategic factors\n     * @returns {number}\n     */\n    evaluate_position_advanced() {\n        const ret = wasm.game_evaluate_position_advanced(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Count immediate threats for a player (winning moves available)\n     * @param {Player} player\n     * @returns {number}\n     */\n    count_threats(player) {\n        const ret = wasm.game_count_threats(this.__wbg_ptr, player);\n        return ret >>> 0;\n    }\n    /**\n     * Get legal moves for Gobang (returns available positions as (row, col) tuples)\n     * Returns a flattened vector where each pair of consecutive elements represents (row, col)\n     * @returns {Uint32Array}\n     */\n    get_legal_moves_gobang() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.game_get_legal_moves_gobang(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Simulate a Gobang move without mutating the current game state\n     * @param {number} row\n     * @param {number} col\n     * @returns {Game}\n     */\n    simulate_move_gobang(row, col) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.game_simulate_move_gobang(retptr, this.__wbg_ptr, row, col);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Game.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get the winner if the game is over, None if it's a draw or ongoing\n     * @returns {Player | undefined}\n     */\n    get_winner() {\n        const ret = wasm.game_get_winner(this.__wbg_ptr);\n        return ret === 0 ? undefined : ret;\n    }\n    /**\n     * Get game phase as enum for external use\n     * @returns {GamePhase}\n     */\n    get_game_phase() {\n        const ret = wasm.game_get_game_phase(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Analyze position for threats and opportunities\n     * @returns {PositionAnalysis}\n     */\n    analyze_position() {\n        const ret = wasm.game_analyze_position(this.__wbg_ptr);\n        return PositionAnalysis.__wrap(ret);\n    }\n    /**\n     * Detect simple fork threats in bottom row: pattern _ x _ x _\n     * Returns columns that must be played to prevent opponent fork\n     * @param {Player} opponent\n     * @returns {Uint32Array}\n     */\n    detect_bottom_row_forks(opponent) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.game_detect_bottom_row_forks(retptr, this.__wbg_ptr, opponent);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get fork-blocking moves for current player (prevent opponent forks)\n     * @returns {Uint32Array}\n     */\n    get_fork_blocking_moves() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.game_get_fork_blocking_moves(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Check if opponent has dangerous fork patterns that require immediate attention\n     * @returns {boolean}\n     */\n    has_critical_fork_threats() {\n        const ret = wasm.game_has_critical_fork_threats(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Detect open three patterns: _ X X X _ (both sides open)\n     * Returns flattened positions where placing a piece would create an open three\n     * Each pair of consecutive elements represents (row, col)\n     * @param {Player} player\n     * @returns {Uint32Array}\n     */\n    detect_open_three(player) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.game_detect_open_three(retptr, this.__wbg_ptr, player);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Detect closed four patterns: O X X X X _ or _ X X X X O (one side blocked)\n     * Returns flattened positions where placing a piece would create a closed four\n     * Each pair of consecutive elements represents (row, col)\n     * @param {Player} player\n     * @returns {Uint32Array}\n     */\n    detect_closed_four(player) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.game_detect_closed_four(retptr, this.__wbg_ptr, player);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Detect double three fork patterns (two open threes intersecting)\n     * Returns flattened positions that would create a double three fork\n     * Each pair of consecutive elements represents (row, col)\n     * @param {Player} player\n     * @returns {Uint32Array}\n     */\n    detect_double_three_forks(player) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.game_detect_double_three_forks(retptr, this.__wbg_ptr, player);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get threat level (0-5) for a potential move\n     * 5 = Immediate win, 4 = Must block, 3 = Strong threat, 2 = Medium, 1 = Weak, 0 = None\n     * @param {number} row\n     * @param {number} col\n     * @param {Player} player\n     * @returns {number}\n     */\n    get_threat_level(row, col, player) {\n        const ret = wasm.game_get_threat_level(this.__wbg_ptr, row, col, player);\n        return ret;\n    }\n    /**\n     * Get dangerous moves for Gobang (moves that give opponent opportunities)\n     * Returns flattened positions - each pair represents (row, col)\n     * @returns {Uint32Array}\n     */\n    get_dangerous_moves_gobang() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.game_get_dangerous_moves_gobang(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get winning moves for Gobang (immediate 5-in-a-row)\n     * Returns flattened positions - each pair represents (row, col)\n     * @returns {Uint32Array}\n     */\n    get_winning_moves_gobang() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.game_get_winning_moves_gobang(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get blocking moves for Gobang (block opponent wins)\n     * Returns flattened positions - each pair represents (row, col)\n     * @returns {Uint32Array}\n     */\n    get_blocking_moves_gobang() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.game_get_blocking_moves_gobang(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst GomokuGameFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_gomokugame_free(ptr >>> 0, 1));\n/**\n * Gomoku/Gobang game implementation using the Three-Layer Architecture\n * Composes geometry and data layers for clean separation of concerns\n */\nexport class GomokuGame {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(GomokuGame.prototype);\n        obj.__wbg_ptr = ptr;\n        GomokuGameFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        GomokuGameFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_gomokugame_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.gomokugame_new();\n        this.__wbg_ptr = ret >>> 0;\n        GomokuGameFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Create a new Gomoku game with a specific starting player\n     * This is essential for game series where \"loser starts next game\"\n     * @param {Player} starting_player\n     * @returns {GomokuGame}\n     */\n    static new_with_starting_player(starting_player) {\n        const ret = wasm.gomokugame_new_with_starting_player(starting_player);\n        return GomokuGame.__wrap(ret);\n    }\n    /**\n     * Make a move at the specified position (row, col)\n     * Gomoku allows free placement anywhere on the board\n     * @param {number} row\n     * @param {number} col\n     * @returns {boolean}\n     */\n    make_move(row, col) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.gomokugame_make_move(retptr, this.__wbg_ptr, row, col);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0 !== 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get cell value at position (0 = empty, 1 = black, 2 = white)\n     * @param {number} row\n     * @param {number} col\n     * @returns {number}\n     */\n    get_cell(row, col) {\n        const ret = wasm.gomokugame_get_cell(this.__wbg_ptr, row, col);\n        return ret;\n    }\n    /**\n     * Get current player\n     * @returns {Player}\n     */\n    current_player() {\n        const ret = wasm.gomokugame_current_player(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get winner (if any)\n     * @returns {Player | undefined}\n     */\n    winner() {\n        const ret = wasm.gomokugame_winner(this.__wbg_ptr);\n        return ret === 0 ? undefined : ret;\n    }\n    /**\n     * Get move count\n     * @returns {number}\n     */\n    move_count() {\n        const ret = wasm.gomokugame_move_count(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Check if position is valid for next move\n     * @param {number} row\n     * @param {number} col\n     * @returns {boolean}\n     */\n    is_valid_move(row, col) {\n        const ret = wasm.gomokugame_is_valid_move(this.__wbg_ptr, row, col);\n        return ret !== 0;\n    }\n    /**\n     * Reset game to initial state\n     */\n    reset() {\n        wasm.gomokugame_newGame(this.__wbg_ptr);\n    }\n    /**\n     * Reset game with a specific starting player\n     * @param {Player} starting_player\n     */\n    reset_with_starting_player(starting_player) {\n        wasm.gomokugame_reset_with_starting_player(this.__wbg_ptr, starting_player);\n    }\n    /**\n     * Start a new game series with \"loser starts\" rule (legacy method)\n     * If loser_starts is true, the losing player from the previous game starts the next game\n     * @param {boolean} loser_starts\n     */\n    start_new_series(loser_starts) {\n        wasm.gomokugame_start_new_series(this.__wbg_ptr, loser_starts);\n    }\n    /**\n     * Start a new game series with fixed player colors\n     * Players keep their colors throughout the series, only start order changes\n     * This is ideal for tournaments where Player A = always Black, Player B = always White\n     * @param {Player} player_a\n     * @param {Player} player_b\n     * @param {Player} winner\n     */\n    start_new_series_with_players(player_a, player_b, winner) {\n        wasm.gomokugame_start_new_series_with_players(this.__wbg_ptr, player_a, player_b, winner);\n    }\n    /**\n     * Get board state as string for debugging\n     * @returns {string}\n     */\n    board_string() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.gomokugame_board_string(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_1(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Check if game is draw (board full, no winner)\n     * @returns {boolean}\n     */\n    is_draw() {\n        const ret = wasm.gomokugame_is_draw(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Check if game is over (win or draw)\n     * @returns {boolean}\n     */\n    is_game_over() {\n        const ret = wasm.gomokugame_is_game_over(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Get current game phase for AI strategy\n     * @returns {GamePhase}\n     */\n    get_game_phase() {\n        const ret = wasm.gomokugame_get_game_phase(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get memory usage of the game state (for performance monitoring)\n     * @returns {number}\n     */\n    memory_usage() {\n        const ret = wasm.gomokugame_memory_usage(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Get current player (frontend naming convention)\n     * @returns {Player}\n     */\n    get_current_player() {\n        const ret = wasm.gomokugame_get_current_player(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get move count (frontend naming convention)\n     * @returns {number}\n     */\n    get_move_count() {\n        const ret = wasm.gomokugame_get_move_count(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Get winner (frontend naming convention)\n     * @returns {Player | undefined}\n     */\n    get_winner() {\n        const ret = wasm.gomokugame_get_winner(this.__wbg_ptr);\n        return ret === 0 ? undefined : ret;\n    }\n    /**\n     * Get board state as flat array for frontend (15 rows × 15 cols = 225 elements)\n     * @returns {Uint8Array}\n     */\n    get_board() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.gomokugame_get_board(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Check if undo is possible\n     * @returns {boolean}\n     */\n    can_undo() {\n        const ret = wasm.gomokugame_can_undo(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Undo the last move\n     * @returns {boolean}\n     */\n    undo_move() {\n        const ret = wasm.gomokugame_undo_move(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Frontend-friendly method aliases\n     */\n    newGame() {\n        wasm.gomokugame_newGame(this.__wbg_ptr);\n    }\n    /**\n     * @returns {boolean}\n     */\n    undoMove() {\n        const ret = wasm.gomokugame_undoMove(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Get AI move suggestion (modern API with Option return type)\n     * @returns {Uint32Array}\n     */\n    get_ai_move() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.gomokugame_get_ai_move(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get AI move suggestion (internal API with proper Option type)\n     * @returns {AiMove | undefined}\n     */\n    get_ai_move_option() {\n        const ret = wasm.gomokugame_get_ai_move_option(this.__wbg_ptr);\n        return ret === 0 ? undefined : AiMove.__wrap(ret);\n    }\n    /**\n     * Get AI move suggestion for specific player\n     * @param {Player} player\n     * @returns {Uint32Array}\n     */\n    get_ai_move_for_player(player) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.gomokugame_get_ai_move_for_player(retptr, this.__wbg_ptr, player);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Evaluate position for current player\n     * @returns {number}\n     */\n    evaluate_position() {\n        const ret = wasm.gomokugame_evaluate_position(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Evaluate position for specific player\n     * @param {Player} player\n     * @returns {number}\n     */\n    evaluate_position_for_player(player) {\n        const ret = wasm.gomokugame_evaluate_position_for_player(this.__wbg_ptr, player);\n        return ret;\n    }\n    /**\n     * Get threat level for a position and player\n     * @param {number} row\n     * @param {number} col\n     * @param {Player} player\n     * @returns {number}\n     */\n    get_threat_level(row, col, player) {\n        const ret = wasm.gomokugame_get_threat_level(this.__wbg_ptr, row, col, player);\n        return ret;\n    }\n    /**\n     * Get winning moves for current player\n     * @returns {Uint32Array}\n     */\n    get_winning_moves() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.gomokugame_get_winning_moves(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get blocking moves (prevent opponent from winning)\n     * @returns {Uint32Array}\n     */\n    get_blocking_moves() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.gomokugame_get_blocking_moves(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Analyze position (Connect4-compatible API)\n     * @returns {string}\n     */\n    analyze_position() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.gomokugame_analyze_position(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_1(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Get threatening moves for current player\n     * @returns {Uint32Array}\n     */\n    get_threatening_moves() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.gomokugame_get_threatening_moves(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Create hypothetical state for AI evaluation\n     * @param {Player} hypothetical_player\n     * @returns {GomokuGame | undefined}\n     */\n    create_hypothetical_state(hypothetical_player) {\n        const ret = wasm.gomokugame_create_hypothetical_state(this.__wbg_ptr, hypothetical_player);\n        return ret === 0 ? undefined : GomokuGame.__wrap(ret);\n    }\n}\n\nconst LGameFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_lgame_free(ptr >>> 0, 1));\n/**\n * L-Game implementation using 3 separate BitPackedBoard<4,4,1>\n * Following Connect4 pattern: separate boards for each piece type\n */\nexport class LGame {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        LGameFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_lgame_free(ptr, 0);\n    }\n    /**\n     * Create new L-Game with initial setup\n     */\n    constructor() {\n        const ret = wasm.lgame_new();\n        this.__wbg_ptr = ret >>> 0;\n        LGameFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get current player\n     * @returns {Player}\n     */\n    get current_player() {\n        const ret = wasm.lgame_current_player(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get move count\n     * @returns {number}\n     */\n    get move_count() {\n        const ret = wasm.lgame_move_count(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Check if game is over\n     * @returns {boolean}\n     */\n    get game_over() {\n        const ret = wasm.lgame_game_over(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Get winner (if any)\n     * @returns {Player | undefined}\n     */\n    get winner() {\n        const ret = wasm.lgame_winner(this.__wbg_ptr);\n        return ret === 0 ? undefined : ret;\n    }\n    /**\n     * Reset game to initial state\n     */\n    reset() {\n        wasm.lgame_reset(this.__wbg_ptr);\n    }\n    /**\n     * Get cell value at position (for JavaScript interface)\n     * Returns: 0=empty, 1=player1, 2=player2, 3=neutral\n     * @param {number} row\n     * @param {number} col\n     * @returns {number}\n     */\n    get_cell(row, col) {\n        const ret = wasm.lgame_get_cell(this.__wbg_ptr, row, col);\n        return ret;\n    }\n    /**\n     * Get complete board state as flat array (for JavaScript)\n     * @returns {Uint8Array}\n     */\n    get_board_state() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.lgame_get_board_state(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get valid moves count (for JavaScript interface)\n     * @returns {number}\n     */\n    get_valid_moves_count() {\n        const ret = wasm.lgame_get_valid_moves_count(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Check if current player is blocked (cannot move L-piece)\n     * @returns {boolean}\n     */\n    is_current_player_blocked() {\n        const ret = wasm.lgame_is_current_player_blocked(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Make a move (L-piece move is mandatory, neutral move is optional)\n     * @param {number} l_to_row\n     * @param {number} l_to_col\n     * @param {number} l_to_orientation\n     */\n    make_move(l_to_row, l_to_col, l_to_orientation) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.lgame_make_move(retptr, this.__wbg_ptr, l_to_row, l_to_col, l_to_orientation);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Move neutral piece (optional part of move)\n     * @param {number} from_row\n     * @param {number} from_col\n     * @param {number} to_row\n     * @param {number} to_col\n     */\n    move_neutral_piece(from_row, from_col, to_row, to_col) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.lgame_move_neutral_piece(retptr, this.__wbg_ptr, from_row, from_col, to_row, to_col);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get game status summary for debugging\n     * @returns {string}\n     */\n    get_status_summary() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.lgame_get_status_summary(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_1(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n\nconst PositionAnalysisFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_positionanalysis_free(ptr >>> 0, 1));\n/**\n * Position analysis structure for AI decision making\n */\nexport class PositionAnalysis {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PositionAnalysis.prototype);\n        obj.__wbg_ptr = ptr;\n        PositionAnalysisFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        PositionAnalysisFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_positionanalysis_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    get current_player_threats() {\n        const ret = wasm.__wbg_get_aimove_row(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} arg0\n     */\n    set current_player_threats(arg0) {\n        wasm.__wbg_set_aimove_row(this.__wbg_ptr, arg0);\n    }\n    /**\n     * @returns {number}\n     */\n    get opponent_threats() {\n        const ret = wasm.__wbg_get_aimove_col(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} arg0\n     */\n    set opponent_threats(arg0) {\n        wasm.__wbg_set_aimove_col(this.__wbg_ptr, arg0);\n    }\n    /**\n     * @returns {number}\n     */\n    get total_pieces() {\n        const ret = wasm.__wbg_get_positionanalysis_total_pieces(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} arg0\n     */\n    set total_pieces(arg0) {\n        wasm.__wbg_set_positionanalysis_total_pieces(this.__wbg_ptr, arg0);\n    }\n    /**\n     * @returns {number}\n     */\n    get connectivity_score() {\n        const ret = wasm.__wbg_get_positionanalysis_connectivity_score(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {number} arg0\n     */\n    set connectivity_score(arg0) {\n        wasm.__wbg_set_positionanalysis_connectivity_score(this.__wbg_ptr, arg0);\n    }\n    /**\n     * @returns {GamePhase}\n     */\n    get game_phase() {\n        const ret = wasm.__wbg_get_positionanalysis_game_phase(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {GamePhase} arg0\n     */\n    set game_phase(arg0) {\n        wasm.__wbg_set_positionanalysis_game_phase(this.__wbg_ptr, arg0);\n    }\n    /**\n     * @returns {number}\n     */\n    get evaluation_score() {\n        const ret = wasm.__wbg_get_positionanalysis_evaluation_score(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {number} arg0\n     */\n    set evaluation_score(arg0) {\n        wasm.__wbg_set_positionanalysis_evaluation_score(this.__wbg_ptr, arg0);\n    }\n    /**\n     * @returns {number}\n     */\n    get get_current_player_threats() {\n        const ret = wasm.positionanalysis_get_current_player_threats(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get get_opponent_threats() {\n        const ret = wasm.positionanalysis_get_opponent_threats(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get get_total_pieces() {\n        const ret = wasm.positionanalysis_get_total_pieces(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get get_connectivity_score() {\n        const ret = wasm.positionanalysis_get_connectivity_score(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {GamePhase}\n     */\n    get get_game_phase() {\n        const ret = wasm.positionanalysis_get_game_phase(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    get get_evaluation_score() {\n        const ret = wasm.positionanalysis_get_evaluation_score(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get threat advantage (positive = current player has more threats)\n     * @returns {number}\n     */\n    threat_advantage() {\n        const ret = wasm.positionanalysis_threat_advantage(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Check if position is tactically critical\n     * @returns {boolean}\n     */\n    is_critical() {\n        const ret = wasm.positionanalysis_is_critical(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Get position summary as string for debugging\n     * @returns {string}\n     */\n    summary() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.positionanalysis_summary(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_1(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n\nconst ReachabilityAnalysisFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_reachabilityanalysis_free(ptr >>> 0, 1));\n\nexport class ReachabilityAnalysis {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ReachabilityAnalysis.prototype);\n        obj.__wbg_ptr = ptr;\n        ReachabilityAnalysisFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ReachabilityAnalysisFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_reachabilityanalysis_free(ptr, 0);\n    }\n    /**\n     * @returns {Int16Array}\n     */\n    get get_reachable_targets() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.reachabilityanalysis_get_reachable_targets(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayI16FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 2, 2);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {Int16Array}\n     */\n    get get_unreachable_targets() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.reachabilityanalysis_get_unreachable_targets(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayI16FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 2, 2);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {number}\n     */\n    get get_total_reachable() {\n        const ret = wasm.reachabilityanalysis_get_total_reachable(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get get_coverage_percentage() {\n        const ret = wasm.reachabilityanalysis_get_coverage_percentage(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    get get_min_reachable() {\n        const ret = wasm.reachabilityanalysis_get_min_reachable(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    get get_max_reachable() {\n        const ret = wasm.reachabilityanalysis_get_max_reachable(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {string}\n     */\n    summary() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.reachabilityanalysis_summary(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_1(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n\nconst SolutionAnalysisFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_solutionanalysis_free(ptr >>> 0, 1));\n\nexport class SolutionAnalysis {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(SolutionAnalysis.prototype);\n        obj.__wbg_ptr = ptr;\n        SolutionAnalysisFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SolutionAnalysisFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_solutionanalysis_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    get get_target() {\n        const ret = wasm.solutionanalysis_get_target(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    get get_total_solutions() {\n        const ret = wasm.solutionanalysis_get_total_solutions(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {string[]}\n     */\n    get get_unique_formulas() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.solutionanalysis_get_unique_formulas(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 4, 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {number}\n     */\n    get get_add_operations() {\n        const ret = wasm.solutionanalysis_get_add_operations(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get get_subtract_operations() {\n        const ret = wasm.solutionanalysis_get_subtract_operations(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get get_difficulty_score() {\n        const ret = wasm.solutionanalysis_get_difficulty_score(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {string}\n     */\n    summary() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.solutionanalysis_summary(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_1(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n\nconst TrioGameFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_triogame_free(ptr >>> 0, 1));\n/**\n * Trio Game using 3-Layer Architecture for clean separation of concerns\n *\n * Trio is a mathematical puzzle game where players find combinations\n * of three LINEAR numbers (a, b, c) that satisfy: a×b+c = target OR a×b-c = target\n *\n * Features:\n * - 7×7 board filled with numbers 1-9\n * - BitPacked storage: 4 bits per cell (supports 0-15, perfect for 1-9)\n * - Linear constraints: Only straight lines (horizontal/vertical/diagonal) allowed\n * - Optimized algorithm: 120 linear patterns instead of 117,649 brute force\n * - Memory efficient: 25 bytes vs 49 bytes naive implementation (49% reduction)\n */\nexport class TrioGame {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TrioGameFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_triogame_free(ptr, 0);\n    }\n    /**\n     * Create new Trio game with specified difficulty\n     * @param {number} difficulty\n     */\n    constructor(difficulty) {\n        const ret = wasm.triogame_new(difficulty);\n        this.__wbg_ptr = ret >>> 0;\n        TrioGameFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Get number at specific board position\n     * @param {number} row\n     * @param {number} col\n     * @returns {number}\n     */\n    get_number(row, col) {\n        const ret = wasm.triogame_get_number(this.__wbg_ptr, row, col);\n        return ret;\n    }\n    /**\n     * Get the current target number to achieve\n     * @returns {number}\n     */\n    get_target_number() {\n        const ret = wasm.triogame_get_target_number(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get current difficulty level\n     * @returns {number}\n     */\n    get_difficulty() {\n        const ret = wasm.triogame_get_difficulty(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Validate a trio combination with adjacency check\n     * Returns the calculated result if valid, or -1 if invalid\n     * @param {number} row1\n     * @param {number} col1\n     * @param {number} row2\n     * @param {number} col2\n     * @param {number} row3\n     * @param {number} col3\n     * @returns {number}\n     */\n    validate_trio(row1, col1, row2, col2, row3, col3) {\n        const ret = wasm.triogame_validate_trio(this.__wbg_ptr, row1, col1, row2, col2, row3, col3);\n        return ret;\n    }\n    /**\n     * Generate new board with specified difficulty\n     * @param {number} difficulty\n     * @returns {number}\n     */\n    generate_new_board(difficulty) {\n        const ret = wasm.triogame_generate_new_board(this.__wbg_ptr, difficulty);\n        return ret;\n    }\n    /**\n     * Find all possible trio solutions using optimized adjacency algorithm\n     * Optimization: Only check valid adjacent triplets (~200) instead of all combinations (117,649)\n     * @returns {Uint8Array}\n     */\n    find_all_solutions() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.triogame_find_all_solutions(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get memory usage of the BitPacked board\n     * @returns {number}\n     */\n    memory_usage() {\n        const ret = wasm.triogame_memory_usage(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Get memory efficiency compared to naive implementation\n     * @returns {number}\n     */\n    memory_efficiency() {\n        const ret = wasm.triogame_memory_efficiency(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get entire board as flat array for JavaScript\n     * @returns {Uint8Array}\n     */\n    get_board_array() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.triogame_get_board_array(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Get count of adjacent patterns for performance info\n     * @returns {number}\n     */\n    get_adjacency_pattern_count() {\n        const ret = wasm.triogame_get_adjacency_pattern_count(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Connect4-compatible API: Get current player\n     * @returns {number}\n     */\n    get_current_player() {\n        const ret = wasm.triogame_get_current_player(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Connect4-compatible API: Make a move (mark found solution)\n     * @param {number} row1\n     * @param {number} col1\n     * @param {number} row2\n     * @param {number} col2\n     * @param {number} row3\n     * @param {number} col3\n     * @returns {boolean}\n     */\n    make_move(row1, col1, row2, col2, row3, col3) {\n        const ret = wasm.triogame_make_move(this.__wbg_ptr, row1, col1, row2, col2, row3, col3);\n        return ret !== 0;\n    }\n    /**\n     * Connect4-compatible API: Reset game\n     */\n    reset() {\n        wasm.triogame_reset(this.__wbg_ptr);\n    }\n    /**\n     * Connect4-compatible API: Get move count\n     * @returns {number}\n     */\n    get_move_count() {\n        const ret = wasm.triogame_get_move_count(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Connect4-compatible API: Get winner (puzzle completed when all solutions found)\n     * @returns {number}\n     */\n    get_winner() {\n        const ret = wasm.triogame_get_winner(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get game phase for UI consistency\n     * @returns {number}\n     */\n    get_game_phase() {\n        const ret = wasm.triogame_get_game_phase(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst TrioGameLegacyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_triogamelegacy_free(ptr >>> 0, 1));\n\nexport class TrioGameLegacy {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TrioGameLegacy.prototype);\n        obj.__wbg_ptr = ptr;\n        TrioGameLegacyFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TrioGameLegacyFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_triogamelegacy_free(ptr, 0);\n    }\n    /**\n     * @param {number} difficulty\n     */\n    constructor(difficulty) {\n        const ret = wasm.triogamelegacy_new(difficulty);\n        this.__wbg_ptr = ret >>> 0;\n        TrioGameLegacyFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {Int8Array}\n     */\n    get_board() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.triogamelegacy_get_board(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            var v1 = getArrayI8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @returns {number}\n     */\n    get_target_number() {\n        const ret = wasm.triogamelegacy_get_target_number(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {number} r1\n     * @param {number} c1\n     * @param {number} r2\n     * @param {number} c2\n     * @param {number} r3\n     * @param {number} c3\n     * @returns {boolean}\n     */\n    check_combination(r1, c1, r2, c2, r3, c3) {\n        const ret = wasm.triogamelegacy_check_combination(this.__wbg_ptr, r1, c1, r2, c2, r3, c3);\n        return ret !== 0;\n    }\n    /**\n     * Create new game with specific distribution (WASM-exposed)\n     * @param {TrioDistribution} distribution\n     * @returns {TrioGameLegacy}\n     */\n    static new_with_distribution_wasm(distribution) {\n        const ret = wasm.triogamelegacy_new_with_distribution_wasm(distribution);\n        return TrioGameLegacy.__wrap(ret);\n    }\n    /**\n     * Analyze reachable targets (WASM-exposed)\n     * @returns {ReachabilityAnalysis}\n     */\n    analyze_reachable_targets_wasm() {\n        const ret = wasm.triogamelegacy_analyze_reachable_targets_wasm(this.__wbg_ptr);\n        return ReachabilityAnalysis.__wrap(ret);\n    }\n    /**\n     * Count solutions for target (WASM-exposed)\n     * @param {number} target\n     * @returns {SolutionAnalysis}\n     */\n    count_solutions_for_target_wasm(target) {\n        const ret = wasm.triogamelegacy_count_solutions_for_target_wasm(this.__wbg_ptr, target);\n        return SolutionAnalysis.__wrap(ret);\n    }\n    /**\n     * Get difficulty category (WASM-exposed)\n     * @param {number} target\n     * @returns {TrioDifficulty}\n     */\n    categorize_target_difficulty_wasm(target) {\n        const ret = wasm.triogamelegacy_categorize_target_difficulty_wasm(this.__wbg_ptr, target);\n        return ret;\n    }\n    /**\n     * Perform comprehensive gap analysis for all distributions\n     * @returns {string}\n     */\n    static comprehensive_gap_analysis() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.triogamelegacy_comprehensive_gap_analysis(retptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_export_1(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {\n        const ret = getObject(arg0).buffer;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_call_672a4d21634d4a24 = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).call(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_call_7cccdd69e0791ae2 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_crypto_574e78ad8b13b65f = function(arg0) {\n        const ret = getObject(arg0).crypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_error_7534b8e9a36f1ab4 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            console.error(getStringFromWasm0(arg0, arg1));\n        } finally {\n            wasm.__wbindgen_export_1(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_getRandomValues_b8f5dbd5f3995a9e = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).getRandomValues(getObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_log_c222819a41e063d3 = function(arg0) {\n        console.log(getObject(arg0));\n    };\n    imports.wbg.__wbg_msCrypto_a61aeb35a24c1329 = function(arg0) {\n        const ret = getObject(arg0).msCrypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_8a6f238a6ece86ea = function() {\n        const ret = new Error();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_a12002a7f91c75be = function(arg0) {\n        const ret = new Uint8Array(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newnoargs_105ed471475aaf50 = function(arg0, arg1) {\n        const ret = new Function(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a = function(arg0, arg1, arg2) {\n        const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithlength_a381634e90c276d4 = function(arg0) {\n        const ret = new Uint8Array(arg0 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_node_905d3e251edff8a2 = function(arg0) {\n        const ret = getObject(arg0).node;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_process_dc0fbacc7c1c06f7 = function(arg0) {\n        const ret = getObject(arg0).process;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_randomFillSync_ac0988aba3254290 = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).randomFillSync(takeObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_require_60cc747a6bc5215a = function() { return handleError(function () {\n        const ret = module.require;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_set_65595bdd868b3009 = function(arg0, arg1, arg2) {\n        getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n    };\n    imports.wbg.__wbg_stack_0ed75d68575b0f3c = function(arg0, arg1) {\n        const ret = getObject(arg1).stack;\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_2, wasm.__wbindgen_export_3);\n        const len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbg_static_accessor_GLOBAL_88a902d13a557d07 = function() {\n        const ret = typeof global === 'undefined' ? null : global;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0 = function() {\n        const ret = typeof globalThis === 'undefined' ? null : globalThis;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_static_accessor_SELF_37c5d418e4bf5819 = function() {\n        const ret = typeof self === 'undefined' ? null : self;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_static_accessor_WINDOW_5de37043a91a9c40 = function() {\n        const ret = typeof window === 'undefined' ? null : window;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    };\n    imports.wbg.__wbg_subarray_aa9065fa9dc5df96 = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_versions_c01dfd4722a88165 = function(arg0) {\n        const ret = getObject(arg0).versions;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_is_function = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'function';\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_object = function(arg0) {\n        const val = getObject(arg0);\n        const ret = typeof(val) === 'object' && val !== null;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_string = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'string';\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_undefined = function(arg0) {\n        const ret = getObject(arg0) === undefined;\n        return ret;\n    };\n    imports.wbg.__wbindgen_memory = function() {\n        const ret = wasm.memory;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_number_new = function(arg0) {\n        const ret = arg0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_object_clone_ref = function(arg0) {\n        const ret = getObject(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {\n        takeObject(arg0);\n    };\n    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {\n        const ret = getStringFromWasm0(arg0, arg1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n\n    return imports;\n}\n\nfunction __wbg_init_memory(imports, memory) {\n\n}\n\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedDataViewMemory0 = null;\n    cachedInt16ArrayMemory0 = null;\n    cachedInt8ArrayMemory0 = null;\n    cachedUint32ArrayMemory0 = null;\n    cachedUint8ArrayMemory0 = null;\n\n\n    wasm.__wbindgen_start();\n    return wasm;\n}\n\nfunction initSync(module) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module !== 'undefined') {\n        if (Object.getPrototypeOf(module) === Object.prototype) {\n            ({module} = module)\n        } else {\n            console.warn('using deprecated parameters for `initSync()`; pass a single object instead')\n        }\n    }\n\n    const imports = __wbg_get_imports();\n\n    __wbg_init_memory(imports);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(module_or_path) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module_or_path !== 'undefined') {\n        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n            ({module_or_path} = module_or_path)\n        } else {\n            console.warn('using deprecated parameters for the initialization function; pass a single object instead')\n        }\n    }\n\n    if (typeof module_or_path === 'undefined') {\n        module_or_path = new URL('game_engine_bg.wasm', import.meta.url);\n    }\n    const imports = __wbg_get_imports();\n\n    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {\n        module_or_path = fetch(module_or_path);\n    }\n\n    __wbg_init_memory(imports);\n\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nexport { initSync };\nexport default __wbg_init;\n"],"names":["wasm","heap","getObject","idx","heap_next","addHeapObject","obj","handleError","f","args","e","cachedTextDecoder","cachedUint8ArrayMemory0","getUint8ArrayMemory0","getStringFromWasm0","ptr","len","dropObject","takeObject","ret","WASM_VECTOR_LEN","cachedTextEncoder","encodeString","arg","view","buf","passStringToWasm0","malloc","realloc","mem","offset","code","cachedDataViewMemory0","getDataViewMemory0","isLikeNone","x","getArrayU8FromWasm0","cachedUint32ArrayMemory0","getUint32ArrayMemory0","getArrayU32FromWasm0","AiMoveFinalization","AiMove","arg0","Connect4GameFinalization","Connect4Game","starting_player","column","retptr","r0","r1","r2","row","col","loser_starts","player_a","player_b","winner","hypothetical_player","deferred1_0","deferred1_1","PositionAnalysis","difficulty","v1","player","GomokuGameFinalization","GomokuGame","LGameFinalization","LGame","l_to_row","l_to_col","l_to_orientation","from_row","from_col","to_row","to_col","PositionAnalysisFinalization","TrioGameFinalization","TrioGame","row1","col1","row2","col2","row3","col3","__wbg_load","module","imports","bytes","instance","__wbg_get_imports","arg1","arg2","deferred0_0","deferred0_1","ptr1","len1","val","__wbg_finalize_init","__wbg_init","module_or_path"],"mappings":"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"}