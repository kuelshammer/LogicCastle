/**
 * EnhancedSmartBot - Advanced strategic bot with sophisticated analysis
 *
 * Features advanced strategic concepts including:
 * - Even/Odd column control strategy
 * - Fork opportunity creation and detection
 * - Zugzwang (tempo) awareness
 * - Multi-level threat analysis
 * - Adaptive center control
 */
class EnhancedSmartBot extends BaseBotStrategy {
  constructor(gameConstants) {
    super(gameConstants);
    this.name = 'enhanced-smart';
    this.description = 'Advanced strategic analysis with pattern recognition';
    this.strategicWeights = {
      centerControl: 3,
      forkCreation: 5,
      patternBreaking: 4,
      evenOddStrategy: 2,
      zugzwang: 3
    };
  }

  /**
     * Select move from safe columns using advanced strategic analysis
     * @param {Object} game - Game instance
     * @param {Array} safeColumns - Array of safe column indices
     * @param {Object} helpers - Helpers instance
     * @returns {number} Selected column index
     */
  selectFromSafeColumns(game, safeColumns, helpers) {
    // Phase 1: Check for opening moves
    if (this.isEarlyGame(game)) {
      const openingMove = this.getOpeningMove(game, safeColumns);
      if (openingMove !== null) {
        return openingMove;
      }
    }

    // Phase 2: Look for fork opportunities
    const forkMove = this.findForkOpportunity(game, safeColumns);
    if (forkMove !== null) {
      return forkMove;
    }

    // Phase 3: Strategic pattern analysis
    const strategicMove = this.getStrategicMove(game, safeColumns, helpers);
    if (strategicMove !== null) {
      return strategicMove;
    }

    // Phase 4: Weighted center preference
    return this.getWeightedCenterMove(game, safeColumns);
  }

  /**
     * Check if game is in early phase
     * @param {Object} game - Game instance
     * @returns {boolean} True if early game
     */
  isEarlyGame(game) {
    return game.moveHistory.length <= 6;
  }

  /**
     * Get opening move using center control strategy
     * @param {Object} game - Game instance
     * @param {Array} safeColumns - Array of safe column indices
     * @returns {number|null} Opening move or null
     */
  getOpeningMove(game, safeColumns) {
    const center = Math.floor(this.COLS / 2); // Column 3 for 7-column board

    // First move: always center if safe
    if (game.moveHistory.length === 0 && safeColumns.includes(center)) {
      return center;
    }

    // Second move: maintain center control or expand
    if (game.moveHistory.length <= 2) {
      // Check if center is still available and safe
      if (safeColumns.includes(center)) {
        return center;
      }

      // Expand to adjacent columns if center taken
      const adjacentColumns = [center - 1, center + 1].filter(col =>
        col >= 0 && col < this.COLS && safeColumns.includes(col)
      );

      if (adjacentColumns.length > 0) {
        return adjacentColumns[Math.floor(Math.random() * adjacentColumns.length)];
      }
    }

    return null;
  }

  /**
     * Find fork creation opportunities
     * @param {Object} game - Game instance
     * @param {Array} safeColumns - Array of safe column indices
     * @returns {number|null} Fork opportunity column or null
     */
  findForkOpportunity(game, safeColumns) {
    // Look for moves that create multiple threats
    for (const col of safeColumns) {
      const result = game.simulateMove(col);
      const threats = this.countThreatsAfterMove(result.game, game.currentPlayer);

      // If this move creates 2+ threats, it's a potential fork
      if (threats >= 2) {
        return col;
      }
    }

    return null;
  }

  /**
     * Count number of threats for a player after a move
     * @param {Object} game - Game instance
     * @param {number} player - Player number
     * @returns {number} Number of winning threats
     */
  countThreatsAfterMove(game, _player) {
    let threatCount = 0;
    const validMoves = game.getValidMoves();

    for (const col of validMoves) {
      const result = game.simulateMove(col);
      if (result.winner === player) {
        threatCount++;
      }
    }

    return threatCount;
  }

  /**
     * Get strategic move using advanced analysis
     * @param {Object} game - Game instance
     * @param {Array} safeColumns - Array of safe column indices
     * @param {Object} helpers - Helpers instance
     * @returns {number|null} Strategic move or null
     */
  getStrategicMove(game, safeColumns, helpers) {
    const moves = safeColumns.map(col => ({
      col: col,
      score: this.evaluateStrategicMove(game, col, helpers)
    }));

    // Sort by score (highest first)
    moves.sort((a, b) => b.score - a.score);

    // Return best move if significantly better than others
    if (moves.length > 1 && moves[0].score > moves[1].score + 5) {
      return moves[0].col;
    }

    return null;
  }

  /**
     * Evaluate strategic value of a move
     * @param {Object} game - Game instance
     * @param {number} col - Column to evaluate
     * @param {Object} helpers - Helpers instance
     * @returns {number} Strategic score
     */
  evaluateStrategicMove(game, col, helpers) {
    let score = 0;
    const center = Math.floor(this.COLS / 2);

    // Center control bonus
    const centerDistance = Math.abs(col - center);
    score += (4 - centerDistance) * this.strategicWeights.centerControl;

    // Even/Odd strategy analysis
    score += this.evaluateEvenOddStrategy(game, col);

    // Pattern disruption bonus
    score += this.evaluatePatternDisruption(game, col);

    // Zugzwang analysis
    score += this.evaluateZugzwang(game, col);

    // Helper system integration
    if (helpers) {
      score += this.getHelperScore(helpers, col);
    }

    return score;
  }

  /**
     * Evaluate even/odd column strategy
     * @param {Object} game - Game instance
     * @param {number} col - Column to evaluate
     * @returns {number} Even/odd strategy score
     */
  evaluateEvenOddStrategy(game, col) {
    const row = this.getLowestEmptyRow(game.board, col);
    if (row === -1) return 0;

    let score = 0;
    const isEvenRow = (row % 2) === 0;
    const isEvenCol = (col % 2) === 0;

    // Prefer controlling even positions in mid-game
    if (game.moveHistory.length >= 8 && game.moveHistory.length <= 20) {
      if (isEvenRow && isEvenCol) {
        score += this.strategicWeights.evenOddStrategy * 2;
      } else if (isEvenRow || isEvenCol) {
        score += this.strategicWeights.evenOddStrategy;
      }
    }

    return score;
  }

  /**
     * Evaluate pattern disruption potential
     * @param {Object} game - Game instance
     * @param {number} col - Column to evaluate
     * @returns {number} Pattern disruption score
     */
  evaluatePatternDisruption(game, col) {
    const opponent = game.currentPlayer === this.PLAYER1 ? this.PLAYER2 : this.PLAYER1;
    const result = game.simulateMove(col);

    // Count opponent patterns we disrupt
    const opponentThreats = this.getOpponentWinningMoves(result.game, opponent);
    const currentOpponentThreats = this.getOpponentWinningMoves(game, opponent);

    const threatsReduced = currentOpponentThreats.length - opponentThreats.length;
    return threatsReduced * this.strategicWeights.patternBreaking;
  }

  /**
     * Evaluate zugzwang (tempo) implications
     * @param {Object} game - Game instance
     * @param {number} col - Column to evaluate
     * @returns {number} Zugzwang score
     */
  evaluateZugzwang(game, col) {
    const result = game.simulateMove(col);
    const opponent = game.currentPlayer === this.PLAYER1 ? this.PLAYER2 : this.PLAYER1;

    // Count forced moves opponent will have
    const opponentForcedMoves = this.countForcedMoves(result.game, opponent);

    // Prefer moves that force opponent into difficult positions
    return opponentForcedMoves * this.strategicWeights.zugzwang;
  }

  /**
     * Count forced moves for a player
     * @param {Object} game - Game instance
     * @param {number} player - Player number
     * @returns {number} Number of forced moves
     */
  countForcedMoves(game, _player) {
    const validMoves = game.getValidMoves();
    let forcedMoves = 0;

    for (const col of validMoves) {
      const result = game.simulateMove(col);
      const opponent = player === this.PLAYER1 ? this.PLAYER2 : this.PLAYER1;

      // Check if opponent has immediate win after this move
      const opponentWins = this.getOpponentWinningMoves(result.game, opponent);
      if (opponentWins.length > 0) {
        forcedMoves++;
      }
    }

    return forcedMoves;
  }

  /**
     * Get score from helper system
     * @param {Object} helpers - Helpers instance
     * @param {number} col - Column to evaluate
     * @returns {number} Helper score
     */
  getHelperScore(helpers, col) {
    try {
      // Use Level 2 helpers for advanced analysis
      helpers.setEnabled(true, 2);
      helpers.updateHints();

      if (helpers.requiredMoves) {
        const requiredMove = helpers.requiredMoves.find(move => move.column === col);
        if (requiredMove) {
          return 10; // High bonus for helper-required moves
        }
      }

      return 0;
    } catch {
      return 0;
    }
  }

  /**
     * Get weighted center move as fallback
     * @param {Object} game - Game instance
     * @param {Array} safeColumns - Array of safe column indices
     * @returns {number} Selected column index
     */
  getWeightedCenterMove(game, safeColumns) {
    const center = Math.floor(this.COLS / 2);

    // Create weights favoring center and near-center columns
    const weights = safeColumns.map(col => {
      const distanceFromCenter = Math.abs(col - center);
      return Math.max(1, 5 - distanceFromCenter);
    });

    // Weighted random selection
    const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
    let randomValue = Math.random() * totalWeight;

    for (let i = 0; i < safeColumns.length; i++) {
      randomValue -= weights[i];
      if (randomValue <= 0) {
        return safeColumns[i];
      }
    }

    return safeColumns[0];
  }

  /**
     * Get strategy info
     * @returns {Object} Strategy information
     */
  getInfo() {
    return {
      name: this.name,
      description: this.description,
      type: 'strategic',
      difficulty: 'hard',
      features: [
        'Advanced pattern recognition',
        'Fork opportunity creation',
        'Even/Odd strategy analysis',
        'Zugzwang evaluation',
        'Multi-phase game analysis',
        'Helper system integration'
      ],
      strategicWeights: this.strategicWeights,
      expectedWinRate: 65 // Against intermediate opponents
    };
  }
}

// Export for both Node.js and browser environments
if (typeof module !== 'undefined' && module.exports) {
  module.exports = EnhancedSmartBot;
} else if (typeof window !== 'undefined') {
  window.EnhancedSmartBot = EnhancedSmartBot;
}
