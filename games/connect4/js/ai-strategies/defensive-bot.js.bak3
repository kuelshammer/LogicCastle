/**
 * DefensiveBot - Pattern disruption and defensive strategy bot
 *
 * Focuses on defensive play by disrupting opponent patterns,
 * controlling key positions, and forcing opponent into difficult situations.
 */
class DefensiveBot extends BaseBotStrategy {
  constructor(gameConstants) {
    super(gameConstants);
    this.name = 'defensive';
    this.description = 'Pattern disruption and defensive positioning';
    this.defensiveWeights = {
      patternBreaking: 6,
      keyPositionControl: 4,
      opponentRestriction: 5,
      safetyMargin: 3
    };
  }

  /**
     * Select move from safe columns using defensive strategy
     * @param {Object} game - Game instance
     * @param {Array} safeColumns - Array of safe column indices
     * @param {Object} helpers - Helpers instance
     * @returns {number} Selected column index
     */
  selectFromSafeColumns(game, safeColumns, _helpers) {
    // Phase 1: Look for critical defensive moves
    const criticalDefensive = this.findCriticalDefensiveMove(game, safeColumns);
    if (criticalDefensive !== null) {
      return criticalDefensive;
    }

    // Phase 2: Pattern disruption analysis
    const patternDisruption = this.findBestPatternDisruption(game, safeColumns);
    if (patternDisruption !== null) {
      return patternDisruption;
    }

    // Phase 3: Key position control
    const keyPosition = this.findKeyPositionMove(game, safeColumns);
    if (keyPosition !== null) {
      return keyPosition;
    }

    // Phase 4: Safest move with opponent restriction
    return this.findSafestRestrictiveMove(game, safeColumns);
  }

  /**
     * Find critical defensive moves (urgent blocks)
     * @param {Object} game - Game instance
     * @param {Array} safeColumns - Array of safe column indices
     * @returns {number|null} Critical defensive move or null
     */
  findCriticalDefensiveMove(game, safeColumns) {
    const opponent = game.currentPlayer === this.PLAYER1 ? this.PLAYER2 : this.PLAYER1;

    // Check for immediate multiple threats from opponent
    const urgentBlocks = [];

    for (const col of safeColumns) {
      const threatsBlocked = this.countThreatsBlocked(game, col, opponent);
      if (threatsBlocked > 0) {
        urgentBlocks.push({ col, threatsBlocked });
      }
    }

    if (urgentBlocks.length > 0) {
      // Sort by number of threats blocked
      urgentBlocks.sort((a, b) => b.threatsBlocked - a.threatsBlocked);
      return urgentBlocks[0].col;
    }

    return null;
  }

  /**
     * Count how many threats a move blocks
     * @param {Object} game - Game instance
     * @param {number} col - Column to evaluate
     * @param {number} opponent - Opponent player number
     * @returns {number} Number of threats blocked
     */
  countThreatsBlocked(game, col, opponent) {
    const currentThreats = this.getOpponentWinningMoves(game, opponent);
    const result = game.simulateMove(col);
    const threatsAfterMove = this.getOpponentWinningMoves(result.game, opponent);

    return currentThreats.length - threatsAfterMove.length;
  }

  /**
     * Find best pattern disruption move
     * @param {Object} game - Game instance
     * @param {Array} safeColumns - Array of safe column indices
     * @returns {number|null} Best pattern disruption move or null
     */
  findBestPatternDisruption(game, safeColumns) {
    const opponent = game.currentPlayer === this.PLAYER1 ? this.PLAYER2 : this.PLAYER1;
    const disruptionScores = [];

    for (const col of safeColumns) {
      const disruptionScore = this.evaluatePatternDisruption(game, col, opponent);
      disruptionScores.push({ col, score: disruptionScore });
    }

    // Sort by disruption score
    disruptionScores.sort((a, b) => b.score - a.score);

    // Return best if significantly better than others
    if (disruptionScores.length > 1 &&
            disruptionScores[0].score > disruptionScores[1].score + 3) {
      return disruptionScores[0].col;
    }

    return null;
  }

  /**
     * Evaluate pattern disruption potential of a move
     * @param {Object} game - Game instance
     * @param {number} col - Column to evaluate
     * @param {number} opponent - Opponent player number
     * @returns {number} Disruption score
     */
  evaluatePatternDisruption(game, col, opponent) {
    let score = 0;
    const result = game.simulateMove(col);
    const row = this.getLowestEmptyRow(game.board, col);

    if (row === -1) return 0;

    // Check how many opponent patterns we disrupt
    score += this.countDisruptedPatterns(game.board, result.game.board, row, col, opponent);

    // Bonus for disrupting central patterns
    const center = Math.floor(this.COLS / 2);
    if (Math.abs(col - center) <= 1) {
      score += 2;
    }

    // Bonus for disrupting in key rows (bottom 3 rows are most important)
    if (row >= this.ROWS - 3) {
      score += 3;
    }

    return score * this.defensiveWeights.patternBreaking;
  }

  /**
     * Count disrupted opponent patterns
     * @param {Array} beforeBoard - Board before move
     * @param {Array} afterBoard - Board after move
     * @param {number} row - Move row
     * @param {number} col - Move column
     * @param {number} opponent - Opponent player
     * @returns {number} Number of patterns disrupted
     */
  countDisruptedPatterns(beforeBoard, afterBoard, row, col, opponent) {
    let disrupted = 0;
    const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];

    for (const [dRow, dCol] of directions) {
      // Check 4-cell windows around the move position
      for (let offset = -3; offset <= 0; offset++) {
        const startRow = row + (dRow * offset);
        const startCol = col + (dCol * offset);

        if (this.isValidWindow(startRow, startCol, dRow, dCol)) {
          const beforePattern = this.getPattern(beforeBoard, startRow, startCol, dRow, dCol);
          const afterPattern = this.getPattern(afterBoard, startRow, startCol, dRow, dCol);

          if (this.isOpponentThreatPattern(beforePattern, opponent) &&
                        !this.isOpponentThreatPattern(afterPattern, opponent)) {
            disrupted++;
          }
        }
      }
    }

    return disrupted;
  }

  /**
     * Check if window position is valid
     * @param {number} startRow - Starting row
     * @param {number} startCol - Starting column
     * @param {number} dRow - Row direction
     * @param {number} dCol - Column direction
     * @returns {boolean} True if valid window
     */
  isValidWindow(startRow, startCol, dRow, dCol) {
    const endRow = startRow + (dRow * 3);
    const endCol = startCol + (dCol * 3);

    return startRow >= 0 && startRow < this.ROWS &&
               startCol >= 0 && startCol < this.COLS &&
               endRow >= 0 && endRow < this.ROWS &&
               endCol >= 0 && endCol < this.COLS;
  }

  /**
     * Get pattern from board window
     * @param {Array} board - Game board
     * @param {number} startRow - Starting row
     * @param {number} startCol - Starting column
     * @param {number} dRow - Row direction
     * @param {number} dCol - Column direction
     * @returns {Array} Pattern array
     */
  getPattern(board, startRow, startCol, dRow, dCol) {
    const pattern = [];
    for (let i = 0; i < 4; i++) {
      const row = startRow + (dRow * i);
      const col = startCol + (dCol * i);
      pattern.push(board[row][col]);
    }
    return pattern;
  }

  /**
     * Check if pattern is an opponent threat
     * @param {Array} pattern - 4-element pattern
     * @param {number} opponent - Opponent player
     * @returns {boolean} True if threat pattern
     */
  isOpponentThreatPattern(pattern, opponent) {
    const opponentCount = pattern.filter(cell => cell === opponent).length;
    const emptyCount = pattern.filter(cell => cell === this.EMPTY).length;

    // Threat if 3 opponent pieces and 1 empty, or 2 opponent pieces and 2 empty
    return (opponentCount === 3 && emptyCount === 1) ||
               (opponentCount === 2 && emptyCount === 2);
  }

  /**
     * Find key position control move
     * @param {Object} game - Game instance
     * @param {Array} safeColumns - Array of safe column indices
     * @returns {number|null} Key position move or null
     */
  findKeyPositionMove(game, safeColumns) {
    const keyPositionScores = [];

    for (const col of safeColumns) {
      const score = this.evaluateKeyPositionControl(game, col);
      keyPositionScores.push({ col, score });
    }

    // Sort by key position score
    keyPositionScores.sort((a, b) => b.score - a.score);

    // Return best key position if significantly valuable
    if (keyPositionScores[0].score > 5) {
      return keyPositionScores[0].col;
    }

    return null;
  }

  /**
     * Evaluate key position control value
     * @param {Object} game - Game instance
     * @param {number} col - Column to evaluate
     * @returns {number} Key position score
     */
  evaluateKeyPositionControl(game, col) {
    let score = 0;
    const row = this.getLowestEmptyRow(game.board, col);

    if (row === -1) return 0;

    // Center control bonus
    const center = Math.floor(this.COLS / 2);
    const centerDistance = Math.abs(col - center);
    score += Math.max(0, 4 - centerDistance) * 2;

    // Bottom row control (most valuable)
    if (row === this.ROWS - 1) {
      score += 5;
    }

    // Even position control (useful for tempo)
    if ((row + col) % 2 === 0) {
      score += 1;
    }

    return score * this.defensiveWeights.keyPositionControl;
  }

  /**
     * Find safest move that restricts opponent
     * @param {Object} game - Game instance
     * @param {Array} safeColumns - Array of safe column indices
     * @returns {number} Safest restrictive move
     */
  findSafestRestrictiveMove(game, safeColumns) {
    const restrictionScores = [];

    for (const col of safeColumns) {
      const restrictionScore = this.evaluateOpponentRestriction(game, col);
      const safetyScore = this.evaluateMoveSafety(game, col);
      const totalScore = restrictionScore + safetyScore;

      restrictionScores.push({ col, score: totalScore });
    }

    // Sort by total score
    restrictionScores.sort((a, b) => b.score - a.score);

    return restrictionScores[0].col;
  }

  /**
     * Evaluate how much a move restricts opponent options
     * @param {Object} game - Game instance
     * @param {number} col - Column to evaluate
     * @returns {number} Restriction score
     */
  evaluateOpponentRestriction(game, col) {
    const opponent = game.currentPlayer === this.PLAYER1 ? this.PLAYER2 : this.PLAYER1;
    const result = game.simulateMove(col);

    const currentOptions = this.countOpponentOptions(game, opponent);
    const futureOptions = this.countOpponentOptions(result.game, opponent);

    const restrictionValue = currentOptions - futureOptions;
    return restrictionValue * this.defensiveWeights.opponentRestriction;
  }

  /**
     * Count strategic options for opponent
     * @param {Object} game - Game instance
     * @param {number} opponent - Opponent player
     * @returns {number} Number of good options
     */
  countOpponentOptions(game, _opponent) {
    const validMoves = game.getValidMoves();
    let goodOptions = 0;

    for (const col of validMoves) {
      const result = game.simulateMove(col);

      // Count as good option if it doesn't give us immediate wins
      const currentPlayer = game.currentPlayer;
      const ourWins = this.getOpponentWinningMoves(result.game, currentPlayer);

      if (ourWins.length === 0) {
        goodOptions++;
      }
    }

    return goodOptions;
  }

  /**
     * Evaluate safety margin of a move
     * @param {Object} game - Game instance
     * @param {number} col - Column to evaluate
     * @returns {number} Safety score
     */
  evaluateMoveSafety(game, col) {
    const result = game.simulateMove(col);
    const _opponent = game.currentPlayer === this.PLAYER1 ? this.PLAYER2 : this.PLAYER1;

    let safetyScore = 0;

    // Check future safety (2 moves ahead)
    const opponentMoves = result.game.getValidMoves();
    let safeOpponentMoves = 0;

    for (const opCol of opponentMoves) {
      const opResult = result.game.simulateMove(opCol);
      const ourThreats = this.getOpponentWinningMoves(opResult.game, game.currentPlayer);

      if (ourThreats.length === 0) {
        safeOpponentMoves++;
      }
    }

    // More safety if opponent has fewer safe options
    safetyScore = Math.max(0, opponentMoves.length - safeOpponentMoves);

    return safetyScore * this.defensiveWeights.safetyMargin;
  }

  /**
     * Get strategy info
     * @returns {Object} Strategy information
     */
  getInfo() {
    return {
      name: this.name,
      description: this.description,
      type: 'defensive',
      difficulty: 'hard',
      features: [
        'Pattern disruption analysis',
        'Key position control',
        'Opponent option restriction',
        'Multi-level threat assessment',
        'Safety margin evaluation'
      ],
      defensiveWeights: this.defensiveWeights,
      expectedWinRate: 70 // Against intermediate opponents
    };
  }
}

// Export for both Node.js and browser environments
if (typeof module !== 'undefined' && module.exports) {
  module.exports = DefensiveBot;
} else if (typeof window !== 'undefined') {
  window.DefensiveBot = DefensiveBot;
}
