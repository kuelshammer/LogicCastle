/**
 * SmartRandomBot - Helpers-assisted bot with heavy randomness
 *
 * Uses helper system for basic strategic awareness but introduces significant
 * randomness to keep gameplay unpredictable and beginner-friendly.
 */
class SmartRandomBot extends BaseBotStrategy {
  constructor(gameConstants) {
    super(gameConstants);
    this.name = 'smart-random';
    this.description = 'Helpers + heavy randomness for unpredictable play';
    this.randomnessLevel = 0.7; // 70% randomness in move selection
  }

  /**
     * Select move from safe columns using helpers + randomness
     * @param {Object} game - Game instance
     * @param {Array} safeColumns - Array of safe column indices
     * @param {Object} helpers - Helpers instance
     * @returns {number} Selected column index
     */
  selectFromSafeColumns(game, safeColumns, helpers) {
    // If we have helpers, try to use them for basic guidance
    if (helpers && Math.random() > this.randomnessLevel) {
      const helperMove = this.getHelperGuidedMove(helpers, safeColumns);
      if (helperMove !== null) {
        return helperMove;
      }
    }

    // Fallback to weighted random selection
    return this.getWeightedRandomMove(game, safeColumns);
  }

  /**
     * Get move suggestion from helpers system
     * @param {Object} helpers - Helpers instance
     * @param {Array} safeColumns - Array of safe column indices
     * @returns {number|null} Helper-suggested column or null
     */
  getHelperGuidedMove(helpers, safeColumns) {
    try {
      // Use Level 0 helpers for basic win/block awareness
      helpers.setEnabled(true, 0);
      helpers.updateHints();

      // Check if helpers suggest any required moves
      if (helpers.requiredMoves && helpers.requiredMoves.length > 0) {
        // Filter required moves to only safe columns
        const safeRequiredMoves = helpers.requiredMoves.filter(move =>
          safeColumns.includes(move.column)
        );

        if (safeRequiredMoves.length > 0) {
          // Pick randomly from safe required moves
          const randomIndex = Math.floor(Math.random() * safeRequiredMoves.length);
          return safeRequiredMoves[randomIndex].column;
        }
      }

      return null;
    } catch {
      // If helpers fail, continue with random selection
      return null;
    }
  }

  /**
     * Get weighted random move favoring center columns
     * @param {Object} game - Game instance
     * @param {Array} safeColumns - Array of safe column indices
     * @returns {number} Selected column index
     */
  getWeightedRandomMove(game, safeColumns) {
    if (safeColumns.length === 0) {
      // Emergency fallback to any valid move
      const validMoves = game.getValidMoves();
      return validMoves[Math.floor(Math.random() * validMoves.length)];
    }

    // Create weights favoring center columns
    const center = Math.floor(this.COLS / 2);
    const weights = safeColumns.map(col => {
      const distanceFromCenter = Math.abs(col - center);
      // Higher weight for center columns
      return Math.max(1, 4 - distanceFromCenter);
    });

    // Weighted random selection
    const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
    let randomValue = Math.random() * totalWeight;

    for (let i = 0; i < safeColumns.length; i++) {
      randomValue -= weights[i];
      if (randomValue <= 0) {
        return safeColumns[i];
      }
    }

    // Fallback to first safe column
    return safeColumns[0];
  }

  /**
     * Simple move evaluation for basic strategic awareness
     * @param {Object} game - Game instance
     * @param {number} col - Column to evaluate
     * @returns {number} Move score
     */
  evaluateMove(game, col) {
    const result = game.simulateMove(col);
    let score = 0;

    // Favor center columns
    const center = Math.floor(this.COLS / 2);
    const centerBonus = Math.max(0, 3 - Math.abs(col - center));
    score += centerBonus * 2;

    // Small bonus for moves that don't give opponent immediate opportunities
    const opponent = game.currentPlayer === this.PLAYER1 ? this.PLAYER2 : this.PLAYER1;
    const opponentThreats = this.getOpponentWinningMoves(result.game, opponent);

    if (opponentThreats.length === 0) {
      score += 5; // Bonus for safe moves
    }

    // Add some randomness to prevent predictable play
    score += Math.random() * 10;

    return score;
  }

  /**
     * Check if this is an opening move
     * @param {Object} game - Game instance
     * @returns {boolean} True if opening phase
     */
  isOpeningMove(game) {
    return game.moveHistory.length < 4;
  }

  /**
     * Get opening move preference
     * @param {Object} game - Game instance
     * @param {Array} safeColumns - Array of safe column indices
     * @returns {number|null} Preferred opening column or null
     */
  getOpeningMove(game, safeColumns) {
    const center = Math.floor(this.COLS / 2);

    // Prefer center column in opening if safe
    if (safeColumns.includes(center)) {
      return center;
    }

    // Otherwise pick randomly from safe columns
    return null;
  }

  /**
     * Adjust randomness based on game phase
     * @param {Object} game - Game instance
     * @returns {number} Adjusted randomness level
     */
  getAdjustedRandomness(game) {
    const moveCount = game.moveHistory.length;
    const totalCells = this.ROWS * this.COLS;
    const gameProgress = moveCount / totalCells;

    // Reduce randomness slightly as game progresses
    if (gameProgress > 0.7) {
      return this.randomnessLevel * 0.8; // Less random in endgame
    } else if (gameProgress < 0.2) {
      return this.randomnessLevel * 1.2; // More random in opening
    }

    return this.randomnessLevel;
  }

  /**
     * Get strategy info
     * @returns {Object} Strategy information
     */
  getInfo() {
    return {
      name: this.name,
      description: this.description,
      type: 'random',
      difficulty: 'easy',
      features: [
        'Helper system integration',
        'Center-biased random selection',
        'High randomness for unpredictability',
        'Basic opening awareness'
      ],
      randomnessLevel: this.randomnessLevel,
      expectedWinRate: 30 // Against intermediate opponents
    };
  }
}

// Export for both Node.js and browser environments
if (typeof module !== 'undefined' && module.exports) {
  module.exports = SmartRandomBot;
} else if (typeof window !== 'undefined') {
  window.SmartRandomBot = SmartRandomBot;
}
