/**
 * Connect4AI - Modular AI Controller for Connect 4
 *
 * This is the refactored AI system that uses extracted bot strategy modules.
 * Maintains backward compatibility while providing better organization and extensibility.
 */
class Connect4AI {
  constructor(difficulty = 'medium') {
    this.difficulty = difficulty;
    this.gameConstants = {
      ROWS: 6,
      COLS: 7,
      EMPTY: 0,
      PLAYER1: 1,
      PLAYER2: 2
    };

    // Initialize strategy registry
    this.strategies = new Map();
    this.initializeStrategies();

    // Cache for performance
    this.cache = new Map();
    this.forkDetector = null;
  }

  /**
     * Initialize all available bot strategies
     */
  initializeStrategies() {
    // Check if strategy classes are available and initialize them
    const availableStrategies = [
      { name: 'smart-random', class: 'SmartRandomBot' },
      { name: 'offensiv-gemischt', class: 'OffensiveMixedBot' },
      { name: 'defensiv-gemischt', class: 'DefensiveMixedBot' },
      { name: 'enhanced-smart', class: 'EnhancedSmartBot' },
      { name: 'defensive', class: 'DefensiveBot' },
      { name: 'monte-carlo', class: 'MonteCarloBot' }
    ];

    for (const strategy of availableStrategies) {
      try {
        if (typeof window !== 'undefined' && window[strategy.class]) {
          this.strategies.set(strategy.name, new window[strategy.class](this.gameConstants));
        } else if (typeof global !== 'undefined' && global[strategy.class]) {
          this.strategies.set(strategy.name, new global[strategy.class](this.gameConstants));
        }
      } catch (error) {
        console.warn(`Could not initialize strategy ${strategy.name}:`, error.message);
      }
    }

    // Fallback to basic strategy if no modules available
    if (this.strategies.size === 0) {
      this.strategies.set('fallback', this.createFallbackStrategy());
    }
  }

  /**
     * Get the best move for the current difficulty
     * @param {Object} game - Game instance
     * @param {Object} helpers - Helpers instance (optional)
     * @returns {number|null} Best move column or null
     */
  getBestMove(game, helpers = null) {
    // Map legacy difficulty names to strategy names
    const strategyName = this.mapDifficultyToStrategy(this.difficulty);

    // Get strategy
    const strategy = this.strategies.get(strategyName);
    if (!strategy) {
      console.warn(`Strategy ${strategyName} not found, using fallback`);
      return this.getFallbackMove(game);
    }

    try {
      // Use the strategy to get the best move
      return strategy.getBestMove(game, helpers);
    } catch (error) {
      console.warn(`Strategy ${strategyName} failed:`, error.message);
      return this.getFallbackMove(game);
    }
  }

  /**
     * Map legacy difficulty names to strategy names
     * @param {string} difficulty - Legacy difficulty name
     * @returns {string} Strategy name
     */
  mapDifficultyToStrategy(difficulty) {
    const mapping = {
      'easy': 'smart-random',
      'smart-random': 'smart-random',
      'medium': 'offensiv-gemischt',
      'offensiv-gemischt': 'offensiv-gemischt',
      'defensiv-gemischt': 'defensiv-gemischt',
      'hard': 'enhanced-smart',
      'enhanced-smart': 'enhanced-smart',
      'strong': 'defensive',
      'defensive': 'defensive',
      'expert': 'monte-carlo',
      'monte-carlo': 'monte-carlo'
    };

    return mapping[difficulty] || 'offensiv-gemischt';
  }

  /**
     * Get fallback move when strategies fail
     * @param {Object} game - Game instance
     * @returns {number|null} Fallback move
     */
  getFallbackMove(game) {
    const fallbackStrategy = this.strategies.get('fallback');
    if (fallbackStrategy) {
      return fallbackStrategy.getBestMove(game);
    }

    // Ultimate fallback: random valid move
    const validMoves = game.getValidMoves();
    if (validMoves.length > 0) {
      return validMoves[Math.floor(Math.random() * validMoves.length)];
    }

    return null;
  }

  /**
     * Create fallback strategy when modules aren't available
     * @returns {Object} Fallback strategy
     */
  createFallbackStrategy() {
    return {
      name: 'fallback',
      getBestMove: (game, _helpers) => {
        const validMoves = game.getValidMoves();
        if (validMoves.length === 0) return null;

        // Simple fallback: try center, then random
        const center = Math.floor(this.gameConstants.COLS / 2);
        if (validMoves.includes(center)) {
          return center;
        }

        return validMoves[Math.floor(Math.random() * validMoves.length)];
      },
      getInfo: () => ({
        name: 'fallback',
        description: 'Basic fallback strategy',
        type: 'fallback'
      })
    };
  }

  /**
     * Get information about current strategy
     * @returns {Object} Strategy information
     */
  getStrategyInfo() {
    const strategyName = this.mapDifficultyToStrategy(this.difficulty);
    const strategy = this.strategies.get(strategyName);

    if (strategy && strategy.getInfo) {
      return strategy.getInfo();
    }

    return {
      name: strategyName,
      description: 'Unknown strategy',
      type: 'unknown',
      difficulty: this.difficulty
    };
  }

  /**
     * Get all available strategies
     * @returns {Array} Array of strategy information
     */
  getAvailableStrategies() {
    const strategies = [];

    for (const [name, strategy] of this.strategies) {
      if (strategy.getInfo) {
        strategies.push(strategy.getInfo());
      } else {
        strategies.push({
          name: name,
          description: 'Legacy strategy',
          type: 'unknown'
        });
      }
    }

    return strategies;
  }

  /**
     * Set AI difficulty/strategy
     * @param {string} difficulty - Difficulty or strategy name
     */
  setDifficulty(difficulty) {
    this.difficulty = difficulty;
    this.cache.clear(); // Clear cache when strategy changes
  }

  /**
     * Get current difficulty
     * @returns {string} Current difficulty
     */
  getDifficulty() {
    return this.difficulty;
  }

  /**
     * Check if a specific strategy is available
     * @param {string} strategyName - Strategy name to check
     * @returns {boolean} True if strategy is available
     */
  hasStrategy(strategyName) {
    return this.strategies.has(strategyName);
  }

  /**
     * Add a custom strategy
     * @param {string} name - Strategy name
     * @param {Object} strategy - Strategy instance
     */
  addStrategy(name, strategy) {
    if (strategy && typeof strategy.getBestMove === 'function') {
      this.strategies.set(name, strategy);
    } else {
      throw new Error('Strategy must have a getBestMove method');
    }
  }

  /**
     * Remove a strategy
     * @param {string} name - Strategy name to remove
     */
  removeStrategy(name) {
    this.strategies.delete(name);
  }

  /**
     * Get performance statistics for current strategy
     * @returns {Object} Performance stats
     */
  getPerformanceStats() {
    const strategyName = this.mapDifficultyToStrategy(this.difficulty);
    const strategy = this.strategies.get(strategyName);

    if (strategy && strategy.getInfo) {
      const info = strategy.getInfo();
      return {
        strategyName: info.name,
        difficulty: info.difficulty,
        expectedWinRate: info.expectedWinRate || 50,
        features: info.features || [],
        type: info.type || 'unknown'
      };
    }

    return {
      strategyName: strategyName,
      difficulty: this.difficulty,
      expectedWinRate: 50,
      features: [],
      type: 'unknown'
    };
  }

  /**
     * Clear AI cache
     */
  clearCache() {
    this.cache.clear();
  }

  /**
     * Get cache statistics
     * @returns {Object} Cache stats
     */
  getCacheStats() {
    return {
      size: this.cache.size,
      maxSize: 1000, // Could be configurable
      hitRate: 0 // Could be tracked
    };
  }

  /**
     * Initialize fork detector if needed (legacy compatibility)
     * @param {Object} game - Game instance
     */
  initializeForkDetector(game) {
    if (!this.forkDetector && typeof Connect4ForkDetection !== 'undefined') {
      this.forkDetector = new Connect4ForkDetection(game);
    }
  }

  /**
     * Get max search depth (legacy compatibility)
     * @param {string} difficulty - Difficulty level
     * @returns {number} Max search depth
     */
  getMaxDepth(difficulty) {
    const depths = {
      'easy': 1,
      'medium': 3,
      'hard': 5,
      'expert': 7
    };
    return depths[difficulty] || 3;
  }
}

// Export for both Node.js and browser environments
if (typeof module !== 'undefined' && module.exports) {
  module.exports = Connect4AI;
} else if (typeof window !== 'undefined') {
  window.Connect4AI = Connect4AI;
}
