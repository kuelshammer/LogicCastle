<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monte Carlo Stage Logic Debug</title>
    <style>
        body { 
            font-family: 'Courier New', monospace; 
            padding: 20px; 
            background: #1a1a1a; 
            color: #00ff00; 
        }
        .test { 
            border: 1px solid #333; 
            padding: 15px; 
            margin: 10px 0; 
            background: #222; 
        }
        .pass { color: #00ff00; }
        .fail { color: #ff0000; }
        h1, h2 { color: #00aaff; }
    </style>
</head>
<body>
    <h1>üéØ MONTE CARLO 4-STAGE LOGIC DEBUG</h1>
    
    <div id="results"></div>
    
    <!-- Load Connect4 classes -->
    <script src="games/connect4/js/game.js"></script>
    <script src="games/connect4/js/ai.js"></script>
    
    <script>
        const results = document.getElementById('results');
        
        function addTest(name, description, testFn) {
            const testDiv = document.createElement('div');
            testDiv.className = 'test';
            
            const title = document.createElement('h2');
            title.textContent = name;
            testDiv.appendChild(title);
            
            const desc = document.createElement('p');
            desc.textContent = description;
            testDiv.appendChild(desc);
            
            try {
                const result = testFn();
                const resultP = document.createElement('p');
                resultP.className = result.pass ? 'pass' : 'fail';
                resultP.innerHTML = `<strong>${result.pass ? '‚úÖ PASS' : '‚ùå FAIL'}</strong>: ${result.message}`;
                testDiv.appendChild(resultP);
            } catch (error) {
                const errorP = document.createElement('p');
                errorP.className = 'fail';
                errorP.innerHTML = `<strong>‚ùå ERROR</strong>: ${error.message}`;
                testDiv.appendChild(errorP);
            }
            
            results.appendChild(testDiv);
        }
        
        // Test 1: Direct Win
        addTest(
            'TEST 1: Direct Win Detection',
            'Monte Carlo should immediately take winning moves (Stage 1)',
            () => {
                const game = new Connect4Game();
                const monteCarlo = new Connect4AI('monte-carlo');
                
                // Set up winning scenario: Red has 3 in a row, can win at column 3
                game.board[5][0] = game.PLAYER1; // Red
                game.board[5][1] = game.PLAYER1; // Red  
                game.board[5][2] = game.PLAYER1; // Red
                
                const move = monteCarlo.getBestMove(game);
                
                return {
                    pass: move === 3,
                    message: `Selected column ${move + 1}, expected column 4`
                };
            }
        );
        
        // Test 2: Block Opponent
        addTest(
            'TEST 2: Block Opponent Win',
            'Monte Carlo should immediately block opponent wins (Stage 2)',
            () => {
                const game = new Connect4Game();
                game.currentPlayer = game.PLAYER1; // Red to move
                const monteCarlo = new Connect4AI('monte-carlo');
                
                // Set up opponent threat: Yellow has 3 in a row, can win at column 3
                game.board[5][0] = game.PLAYER2; // Yellow
                game.board[5][1] = game.PLAYER2; // Yellow
                game.board[5][2] = game.PLAYER2; // Yellow
                
                const move = monteCarlo.getBestMove(game);
                
                return {
                    pass: move === 3,
                    message: `Selected column ${move + 1}, expected column 4 (block)`
                };
            }
        );
        
        // Test 3: Avoid Traps
        addTest(
            'TEST 3: Avoid Trapped Columns',
            'Monte Carlo should avoid columns that create opponent wins (Stage 3)',
            () => {
                const game = new Connect4Game();
                game.currentPlayer = game.PLAYER1; // Red to move
                const monteCarlo = new Connect4AI('monte-carlo');
                
                // Create a trapped position in column 0
                for (let row = 2; row < 6; row++) {
                    game.board[row][0] = row % 2 === 0 ? game.PLAYER1 : game.PLAYER2;
                }
                game.board[1][0] = game.PLAYER2;
                game.board[0][0] = game.PLAYER2; // Column 0 is trapped
                
                const move = monteCarlo.getBestMove(game);
                
                return {
                    pass: move !== 0,
                    message: `Selected column ${move + 1}, should NOT be column 1 (trapped)`
                };
            }
        );
        
        // Test 4: Verify Simulation Usage
        addTest(
            'TEST 4: Monte Carlo Simulation Stage',
            'Monte Carlo should use simulation for non-critical moves (Stage 4)',
            () => {
                const game = new Connect4Game();
                const monteCarlo = new Connect4AI('monte-carlo');
                
                // Simple mid-game position - no immediate wins/blocks/traps
                game.board[5][3] = game.PLAYER1; // Red center
                game.board[4][3] = game.PLAYER2; // Yellow on top
                
                // Track if simulation method is called
                let simulationCalled = false;
                const originalSelect = monteCarlo.selectMonteCarloFromSafe;
                
                monteCarlo.selectMonteCarloFromSafe = function(...args) {
                    simulationCalled = true;
                    console.log('üéØ Monte Carlo simulation called!');
                    return originalSelect.apply(this, args);
                };
                
                const move = monteCarlo.getBestMove(game);
                
                return {
                    pass: simulationCalled,
                    message: `Simulation ${simulationCalled ? 'WAS' : 'was NOT'} called for column ${move + 1}`
                };
            }
        );
        
        // Test 5: Check Stage Order with Logging
        addTest(
            'TEST 5: Stage Order Verification',
            'Verify that stages are executed in correct order with logging',
            () => {
                const game = new Connect4Game();
                const monteCarlo = new Connect4AI('monte-carlo');
                
                // Capture console logs
                const logs = [];
                const originalLog = console.log;
                console.log = (...args) => {
                    logs.push(args.join(' '));
                    originalLog(...args);
                };
                
                // Simple position that should go through all stages
                const move = monteCarlo.getBestMove(game);
                
                // Restore console
                console.log = originalLog;
                
                // Check for stage logging
                const hasStage1 = logs.some(log => log.includes('STAGE 1') || log.includes('Direct win'));
                const hasStage2 = logs.some(log => log.includes('STAGE 2') || log.includes('Blocking'));
                const hasStage3 = logs.some(log => log.includes('STAGE 3') || log.includes('Safe columns'));
                const hasStage4 = logs.some(log => log.includes('STAGE 4') || log.includes('selected'));
                
                return {
                    pass: hasStage3 && hasStage4, // At minimum should see stage 3 and 4
                    message: `Stages detected - 1:${hasStage1}, 2:${hasStage2}, 3:${hasStage3}, 4:${hasStage4}. Move: ${move + 1}`
                };
            }
        );
        
        console.log('üèÅ Monte Carlo Stage Logic Tests Completed');
    </script>
</body>
</html>