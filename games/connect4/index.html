<!doctype html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>4 Gewinnt - LogicCastle</title>
    <!-- Production-optimized Tailwind CSS build -->
    <link rel="stylesheet" href="css/tailwind-built.css" />
    <!-- Legacy CSS for gradual migration -->
    <link rel="stylesheet" href="css/game.css" />
    <link rel="stylesheet" href="css/ui.css" />
    <style>
      .game-slot {
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .game-slot:hover {
        transform: scale(1.05);
      }
      .disc {
        transition: all 0.5s ease;
      }
      .disc.yellow {
        background: linear-gradient(135deg, #FFD700, #FFA000) !important;
        border: 3px solid #FF8F00 !important;
        box-shadow: 0 4px 12px rgba(255, 215, 0, 0.6) !important;
      }
      .disc.red {
        background: linear-gradient(135deg, #F44336, #D32F2F) !important;
        border: 3px solid #C62828 !important;
        box-shadow: 0 4px 12px rgba(244, 67, 54, 0.6) !important;
      }
      .disc.empty {
        background: rgba(255, 255, 255, 0.1) !important;
        border: 1px solid rgba(255, 255, 255, 0.2) !important;
      }
      .winning-disc {
        animation: winningGlow 1s ease-in-out infinite;
      }
      @keyframes winningGlow {
        0%, 100% { 
          box-shadow: 0 0 20px rgba(255, 215, 0, 0.8),
                      0 0 40px rgba(255, 215, 0, 0.6),
                      inset 0 0 15px rgba(255, 255, 255, 0.3);
          transform: scale(1);
        }
        50% { 
          box-shadow: 0 0 40px rgba(255, 215, 0, 1),
                      0 0 80px rgba(255, 215, 0, 0.8),
                      inset 0 0 25px rgba(255, 255, 255, 0.5);
          transform: scale(1.1);
        }
      }
    </style>
  </head>
  <body class="min-h-screen bg-gradient-to-br from-blue-900 via-purple-900 to-indigo-900">
    <!-- Background decoration -->
    <div class="fixed inset-0 overflow-hidden pointer-events-none">
        <div class="absolute -top-40 -right-40 w-80 h-80 bg-blue-500 rounded-full mix-blend-multiply filter blur-xl opacity-70 animate-pulse"></div>
        <div class="absolute -bottom-40 -left-40 w-80 h-80 bg-purple-500 rounded-full mix-blend-multiply filter blur-xl opacity-70 animate-pulse" style="animation-delay: 1s;"></div>
        <div class="absolute top-40 left-1/2 w-80 h-80 bg-indigo-500 rounded-full mix-blend-multiply filter blur-xl opacity-70 animate-pulse" style="animation-delay: 2s;"></div>
    </div>

    <div class="relative z-10" data-current-player="1">
      <!-- Header -->
      <header class="p-6 text-center">
        <div class="max-w-6xl mx-auto">
          <div class="flex items-center justify-between mb-4">
            <a href="../../index.html" class="glass px-4 py-2 rounded-xl text-white hover:bg-white hover:bg-opacity-20 transition-all duration-200">
              ‚Üê Zur√ºck zu LogicCastle
            </a>
            <div class="glass px-4 py-2 rounded-xl">
              <label for="gameMode" class="text-white text-sm mr-2">Modus:</label>
              <select id="gameMode" class="bg-transparent text-white border-none focus:outline-none">
                <option value="two-player" class="text-gray-900">2 Spieler</option>
                <option value="vs-bot-easy" class="text-gray-900">vs Einfache KI</option>
                <option value="vs-bot-medium" class="text-gray-900">vs Mittlere KI</option>
                <option value="vs-bot-hard" class="text-gray-900">vs Schwere KI</option>
              </select>
            </div>
          </div>
          <h1 class="text-4xl md:text-6xl font-bold text-white mb-2">
            <span class="inline-block w-8 h-8 bg-gradient-to-br from-red-500 to-yellow-500 rounded-full mr-3 align-middle"></span>
            4 Gewinnt
          </h1>
          <p class="text-lg md:text-xl text-white opacity-90">Modular ‚Ä¢ BitPacked ‚Ä¢ KI-Enhanced</p>
        </div>
      </header>

      <!-- Main Game Container with Responsive Grid -->
      <main class="relative z-10 max-w-7xl mx-auto p-6">
        <div class="grid grid-cols-1 xl:grid-cols-4 gap-6">
          
          <!-- Game Board Section (3/4 width on large screens) -->
          <div class="xl:col-span-3">
            <div class="glass rounded-3xl p-8 shadow-2xl" data-current-player="1">
              <!-- Column Coordinates Top -->
              <div class="grid grid-cols-7 gap-2 mb-4 px-4" id="topCoords">
                <div class="coord text-center text-white font-bold cursor-pointer hover:bg-white hover:bg-opacity-20 py-2 rounded">1</div>
                <div class="coord text-center text-white font-bold cursor-pointer hover:bg-white hover:bg-opacity-20 py-2 rounded">2</div>
                <div class="coord text-center text-white font-bold cursor-pointer hover:bg-white hover:bg-opacity-20 py-2 rounded">3</div>
                <div class="coord text-center text-white font-bold cursor-pointer hover:bg-white hover:bg-opacity-20 py-2 rounded">4</div>
                <div class="coord text-center text-white font-bold cursor-pointer hover:bg-white hover:bg-opacity-20 py-2 rounded">5</div>
                <div class="coord text-center text-white font-bold cursor-pointer hover:bg-white hover:bg-opacity-20 py-2 rounded">6</div>
                <div class="coord text-center text-white font-bold cursor-pointer hover:bg-white hover:bg-opacity-20 py-2 rounded">7</div>
              </div>
              
              <!-- Game Board Container -->
              <div class="relative">
                <div class="game-board grid grid-cols-7 grid-rows-6 gap-2 p-4 rounded-2xl shadow-2xl bg-gradient-to-br from-blue-600 to-blue-800 aspect-[7/6] max-w-2xl mx-auto" id="gameBoard">
                  <!-- 42 cells will be generated by JavaScript -->
                </div>
                <!-- Particle Engine Canvas for Victory Celebrations -->
                <canvas id="particleCanvas" 
                        class="absolute inset-0 w-full h-full pointer-events-none z-50">
                </canvas>
              </div>
              
              <!-- Column Coordinates Bottom -->
              <div class="grid grid-cols-7 gap-2 mt-4 px-4" id="bottomCoords">
                <div class="coord text-center text-white font-bold cursor-pointer hover:bg-white hover:bg-opacity-20 py-2 rounded">1</div>
                <div class="coord text-center text-white font-bold cursor-pointer hover:bg-white hover:bg-opacity-20 py-2 rounded">2</div>
                <div class="coord text-center text-white font-bold cursor-pointer hover:bg-white hover:bg-opacity-20 py-2 rounded">3</div>
                <div class="coord text-center text-white font-bold cursor-pointer hover:bg-white hover:bg-opacity-20 py-2 rounded">4</div>
                <div class="coord text-center text-white font-bold cursor-pointer hover:bg-white hover:bg-opacity-20 py-2 rounded">5</div>
                <div class="coord text-center text-white font-bold cursor-pointer hover:bg-white hover:bg-opacity-20 py-2 rounded">6</div>
                <div class="coord text-center text-white font-bold cursor-pointer hover:bg-white hover:bg-opacity-20 py-2 rounded">7</div>
              </div>
            </div>
          </div>
          
          <!-- Game Info Sidebar (1/4 width) -->
          <div class="space-y-6">
            <!-- Current Player Status -->
            <div class="glass rounded-2xl p-6 shadow-xl">
              <h3 class="text-xl font-bold text-white mb-4">Aktueller Spieler</h3>
              <div class="flex items-center justify-center">
                <span class="player-indicator flex items-center" id="currentPlayerIndicator">
                  <span class="player-disc w-8 h-8 rounded-full mr-3 bg-gradient-to-br from-yellow-400 to-yellow-600 shadow-lg"></span>
                  <span class="player-name text-white font-semibold">Spieler 1</span>
                </span>
              </div>
            </div>

            <!-- Score Board -->
            <div class="glass rounded-2xl p-6 shadow-xl">
              <h3 class="text-xl font-bold text-white mb-4">Spielstand</h3>
              <div class="space-y-4">
                <div class="flex items-center justify-between text-white">
                  <div class="flex items-center">
                    <div class="w-4 h-4 rounded-full bg-gradient-to-br from-yellow-400 to-yellow-600 mr-2"></div>
                    <span>Gelb</span>
                  </div>
                  <span id="yellowScore" class="text-2xl font-bold text-yellow-400">0</span>
                </div>
                <div class="flex items-center justify-between text-white">
                  <div class="flex items-center">
                    <div class="w-4 h-4 rounded-full bg-gradient-to-br from-red-500 to-red-700 mr-2"></div>
                    <span>Rot</span>
                  </div>
                  <span id="redScore" class="text-2xl font-bold text-red-400">0</span>
                </div>
              </div>
            </div>

            <!-- Game Status -->
            <div class="glass rounded-2xl p-6 shadow-xl">
              <h3 class="text-xl font-bold text-white mb-4">Spiel-Info</h3>
              <div class="space-y-3 text-white">
                <div class="flex justify-between">
                  <span>Status:</span>
                  <span id="gameStatus" class="font-semibold text-green-400">Spiel l√§uft</span>
                </div>
                <div class="flex justify-between">
                  <span>Z√ºge:</span>
                  <span id="moveCounter" class="font-bold">0</span>
                </div>
              </div>
            </div>

            <!-- Game Controls -->
            <div class="glass rounded-2xl p-6 shadow-xl">
              <h3 class="text-xl font-bold text-white mb-4">Steuerung</h3>
              <div class="space-y-3">
                <button id="newGameBtn" class="w-full bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 text-white font-semibold py-3 px-4 rounded-xl transition-all duration-200 shadow-lg glass-hover">
                  üÜï Neues Spiel (N)
                </button>
                <button id="undoBtn" class="w-full glass-dark text-white font-semibold py-3 px-4 rounded-xl hover:bg-white hover:bg-opacity-10 transition-all duration-200 disabled:opacity-50" disabled>
                  ‚Ü∂ R√ºckg√§ngig (U)
                </button>
                <button id="resetScoreBtn" class="w-full bg-gradient-to-r from-orange-500 to-red-600 hover:from-orange-600 hover:to-red-700 text-white font-semibold py-3 px-4 rounded-xl transition-all duration-200 shadow-lg glass-hover">
                  üîÑ Score zur√ºcksetzen (F3)
                </button>
                <button id="assistanceBtn" class="w-full bg-gradient-to-r from-blue-500 to-cyan-600 hover:from-blue-600 hover:to-cyan-700 text-white font-semibold py-3 px-4 rounded-xl transition-all duration-200 shadow-lg glass-hover">
                  üéõÔ∏è Spielerhilfen (F2)
                </button>
                <button id="helpBtn" class="w-full bg-gradient-to-r from-purple-500 to-pink-600 hover:from-purple-600 hover:to-pink-700 text-white font-semibold py-3 px-4 rounded-xl transition-all duration-200 shadow-lg glass-hover">
                  ‚ùì Spielanleitung (F1)
                </button>
              </div>
            </div>
          </div>
        </div>

      </main>
    </div>

    <!-- Modern Player Assistance Modal -->
    <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden" id="assistanceModal">
      <div class="glass rounded-3xl p-8 max-w-4xl mx-4 max-h-[90vh] overflow-y-auto">
        <div class="flex items-center justify-between mb-6">
          <h2 class="text-3xl font-bold text-white">üéõÔ∏è Spielerhilfen</h2>
          <button class="glass-hover rounded-xl p-2 text-white hover:bg-white hover:bg-opacity-20 transition-all duration-200" id="closeAssistanceModal">
            ‚úï
          </button>
        </div>
        <div class="text-white">
          <p>Spielerhilfen sind in der minimalen Version deaktiviert.</p>
        </div>
      </div>
    </div>

    <!-- Help Modal -->
    <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden" id="helpModal">
      <div class="glass rounded-3xl p-8 max-w-4xl mx-4 max-h-[90vh] overflow-y-auto">
        <div class="flex items-center justify-between mb-6">
          <h2 class="text-3xl font-bold text-white">‚ùì Spielanleitung</h2>
          <button class="glass-hover rounded-xl p-2 text-white hover:bg-white hover:bg-opacity-20 transition-all duration-200" id="closeHelpModal">
            ‚úï
          </button>
        </div>
        <div class="text-white space-y-4">
          <h3 class="text-xl font-bold">üéØ Spielziel</h3>
          <p>Verbinde vier deiner Spielsteine in einer geraden Linie (horizontal, vertikal oder diagonal)!</p>
          
          <h3 class="text-xl font-bold">üéÆ Steuerung</h3>
          <ul class="list-disc list-inside space-y-2">
            <li><strong>Klick:</strong> Stein in Spalte einwerfen</li>
            <li><strong>1-7:</strong> Stein in Spalte 1-7 einwerfen</li>
            <li><strong>N:</strong> Neues Spiel</li>
            <li><strong>U:</strong> Zug r√ºckg√§ngig</li>
            <li><strong>F1:</strong> Hilfe √∂ffnen/schlie√üen</li>
          </ul>
          
          <h3 class="text-xl font-bold">üìã Regeln</h3>
          <ul class="list-disc list-inside space-y-2">
            <li>Gelb beginnt</li>
            <li>Steine fallen durch die Schwerkraft nach unten</li>
            <li>4 Steine in einer Reihe gewinnen</li>
            <li>Bei vollem Brett ohne Gewinner: Unentschieden</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- VEREINFACHTES CDN-ONLY SYSTEM -->
    <script>
      console.log('üöÄ CDN-ONLY SYSTEM INITIALIZATION...');
      
      // Local Module URLs (Relative Paths f√ºr GitHub Pages Kompatibilit√§t)
      const LOCAL_MODULES = {
        'BaseGameUI': './js/modules/core/BaseGameUI.js',
        'ElementBinder': './js/modules/core/ElementBinder.js',
        'EventDispatcher': './js/modules/core/EventDispatcher.js',
        'BoardRenderer': './js/components/BoardRenderer.js',
        'Connect4Config': './js/connect4-config.js'
      };
      
      // Lokaler Module Loader
      async function loadLocalModule(moduleName) {
        const localUrl = LOCAL_MODULES[moduleName];
        console.log(`üì¶ Loading ${moduleName} from local: ${localUrl}`);
        
        try {
          const module = await import(localUrl);
          console.log(`‚úÖ Local import success for ${moduleName}`);
          return module;
        } catch (error) {
          console.error(`‚ùå Local import failed for ${moduleName}:`, error.message);
          throw error;
        }
      }
      
      // Initialize modular Connect4 with lokalen Modulen
      async function initializeLocalConnect4() {
        console.log('üéÆ Initializing Local Connect4...');
        
        try {
          // Load modules from local paths
          const baseGameUI = await loadLocalModule('BaseGameUI');
          const boardRenderer = await loadLocalModule('BoardRenderer');
          const connect4Config = await loadLocalModule('Connect4Config');
          
          const BaseGameUI = baseGameUI.BaseGameUI;
          const BoardRenderer = boardRenderer.BoardRenderer;
          const configModule = connect4Config;
          
          console.log('‚úÖ All local modules loaded successfully');
          
          // Create configuration
          const config = configModule.createConnect4Config ? 
            configModule.createConnect4Config('two-player') : 
            configModule.CONNECT4_UI_CONFIG;
          
          // Create modular game class
          class LocalConnect4Game extends BaseGameUI {
              constructor() {
                super(null, config);
                this.boardRenderer = null;
                
                // Game state
                this.board = Array(6).fill(null).map(() => Array(7).fill(0));
                this.currentPlayer = 1;
                this.gameOver = false;
                this.winner = null;
                this.moveCount = 0;
                this.gameHistory = [];
                this.scores = { yellow: 0, red: 0 };
                
                console.log('üéÆ LocalConnect4Game created with modular architecture');
              }
              
              async init() {
                console.log('üîÑ Initializing Local Connect4...');
                
                try {
                  await super.init();
                  console.log('‚úÖ BaseGameUI initialized');
                } catch (error) {
                  console.warn('‚ö†Ô∏è BaseGameUI init failed, continuing anyway:', error);
                }
                
                // Initialize BoardRenderer if available
                if (BoardRenderer) {
                  this.initializeBoardRenderer();
                }
                
                // Initialize game
                this.createBoard();
                this.setupEventListeners();
                this.updateUI();
                
                console.log('‚úÖ Local Connect4 initialized successfully');
                return true;
              }
              
              initializeBoardRenderer() {
                const gameBoard = document.getElementById('gameBoard');
                const topCoords = document.getElementById('topCoords');
                const bottomCoords = document.getElementById('bottomCoords');
                
                if (gameBoard && BoardRenderer) {
                  this.boardRenderer = new BoardRenderer(gameBoard, topCoords, bottomCoords);
                  console.log('üéØ BoardRenderer initialized from local modules');
                } else {
                  console.warn('‚ö†Ô∏è BoardRenderer not available or gameBoard not found');
                }
              }
              
              createBoard() {
                // Use BoardRenderer if available
                if (this.boardRenderer) {
                  const success = this.boardRenderer.initializeBoard();
                  if (success) {
                    this.boardRenderer.createCoordinateLabels();
                    console.log('üéØ Board created using local BoardRenderer');
                    return;
                  }
                }
                
                // Fallback to manual board creation
                this.createBoardManually();
              }
              
              createBoardManually() {
                const gameBoard = document.getElementById('gameBoard');
                if (!gameBoard) {
                  console.error('‚ùå Game board element not found');
                  return;
                }
                
                gameBoard.innerHTML = '';
                
                // Create 42 cells
                for (let row = 0; row < 6; row++) {
                  for (let col = 0; col < 7; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'game-slot relative bg-blue-500 rounded-full border-2 border-blue-700 cursor-pointer aspect-square flex items-center justify-center';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    const disc = document.createElement('div');
                    disc.className = 'disc empty w-[85%] h-[85%] rounded-full';
                    disc.style.background = 'rgba(255, 255, 255, 0.1)';
                    disc.style.border = '1px solid rgba(255, 255, 255, 0.2)';
                    
                    cell.appendChild(disc);
                    gameBoard.appendChild(cell);
                  }
                }
                
                console.log('üéØ Board created manually (42 cells)');
              }
              
              setupEventListeners() {
                // Board click handler
                const gameBoard = document.getElementById('gameBoard');
                if (gameBoard) {
                  gameBoard.addEventListener('click', (e) => {
                    const cell = e.target.closest('.game-slot');
                    if (cell && !this.gameOver) {
                      const col = parseInt(cell.dataset.col);
                      this.makeMove(col);
                    }
                  });
                }
                
                // Column coordinates click handler
                document.querySelectorAll('.coord').forEach((coord, index) => {
                  coord.addEventListener('click', () => {
                    if (!this.gameOver) {
                      this.makeMove(index);
                    }
                  });
                });
                
                // Button handlers
                const newGameBtn = document.getElementById('newGameBtn');
                if (newGameBtn) {
                  newGameBtn.addEventListener('click', () => this.resetGame());
                }
                
                const undoBtn = document.getElementById('undoBtn');
                if (undoBtn) {
                  undoBtn.addEventListener('click', () => this.undoMove());
                }
                
                const resetScoreBtn = document.getElementById('resetScoreBtn');
                if (resetScoreBtn) {
                  resetScoreBtn.addEventListener('click', () => this.resetScore());
                }
                
                // Modal handlers
                const helpBtn = document.getElementById('helpBtn');
                if (helpBtn) {
                  helpBtn.addEventListener('click', () => this.showModal('helpModal'));
                }
                
                const assistanceBtn = document.getElementById('assistanceBtn');
                if (assistanceBtn) {
                  assistanceBtn.addEventListener('click', () => this.showModal('assistanceModal'));
                }
                
                // Close modal handlers
                const closeHelpModal = document.getElementById('closeHelpModal');
                if (closeHelpModal) {
                  closeHelpModal.addEventListener('click', () => this.hideModal('helpModal'));
                }
                
                const closeAssistanceModal = document.getElementById('closeAssistanceModal');
                if (closeAssistanceModal) {
                  closeAssistanceModal.addEventListener('click', () => this.hideModal('assistanceModal'));
                }
                
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                  if (e.key >= '1' && e.key <= '7' && !this.gameOver) {
                    const col = parseInt(e.key) - 1;
                    this.makeMove(col);
                  } else if (e.key === 'n' || e.key === 'N') {
                    this.resetGame();
                  } else if (e.key === 'u' || e.key === 'U') {
                    this.undoMove();
                  } else if (e.key === 'F1') {
                    e.preventDefault();
                    this.toggleModal('helpModal');
                  } else if (e.key === 'F2') {
                    e.preventDefault();
                    this.toggleModal('assistanceModal');
                  } else if (e.key === 'F3') {
                    e.preventDefault();
                    this.resetScore();
                  } else if (e.key === 'Escape') {
                    this.hideModal('helpModal');
                    this.hideModal('assistanceModal');
                  }
                });
                
                console.log('üéÆ Event listeners set up for Local Connect4');
              }
              
              makeMove(col) {
                if (this.gameOver || col < 0 || col >= 7) return false;
                
                // Find lowest empty row in column
                let targetRow = -1;
                for (let row = 5; row >= 0; row--) {
                  if (this.board[row][col] === 0) {
                    targetRow = row;
                    break;
                  }
                }
                
                if (targetRow === -1) return false; // Column full
                
                // Save move for undo
                this.gameHistory.push({
                  row: targetRow,
                  col: col,
                  player: this.currentPlayer,
                  board: this.board.map(row => [...row])
                });
                
                // Make the move
                this.board[targetRow][col] = this.currentPlayer;
                this.moveCount++;
                
                // Update visual
                this.updateCell(targetRow, col, this.currentPlayer);
                
                // Check for win
                if (this.checkWin(targetRow, col)) {
                  this.gameOver = true;
                  this.winner = this.currentPlayer;
                  this.showWin(targetRow, col);
                  this.updateScore();
                } else if (this.moveCount === 42) {
                  this.gameOver = true;
                  this.winner = 0; // Draw
                  this.showDraw();
                } else {
                  // Switch player
                  this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
                }
                
                this.updateUI();
                return true;
              }
              
              updateCell(row, col, player) {
                // Use BoardRenderer if available
                if (this.boardRenderer && this.boardRenderer.updateBoardVisual) {
                  this.boardRenderer.updateBoardVisual(row, col, player);
                } else {
                  // Fallback to direct DOM manipulation
                  const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                  if (cell) {
                    const disc = cell.querySelector('.disc');
                    if (disc) {
                      disc.classList.remove('empty', 'yellow', 'red');
                      disc.classList.add(player === 1 ? 'yellow' : 'red');
                      
                      if (player === 1) {
                        disc.style.background = 'linear-gradient(135deg, #FFD700, #FFA000)';
                        disc.style.border = '3px solid #FF8F00';
                        disc.style.boxShadow = '0 4px 12px rgba(255, 215, 0, 0.6)';
                      } else {
                        disc.style.background = 'linear-gradient(135deg, #F44336, #D32F2F)';
                        disc.style.border = '3px solid #C62828';
                        disc.style.boxShadow = '0 4px 12px rgba(244, 67, 54, 0.6)';
                      }
                    }
                  }
                }
              }
              
              checkWin(row, col) {
                const player = this.board[row][col];
                const directions = [
                  [0, 1],  // horizontal
                  [1, 0],  // vertical
                  [1, 1],  // diagonal /
                  [1, -1]  // diagonal \
                ];
                
                for (const [dr, dc] of directions) {
                  let count = 1;
                  const line = [[row, col]];
                  
                  // Check positive direction
                  for (let i = 1; i < 4; i++) {
                    const r = row + i * dr;
                    const c = col + i * dc;
                    if (r >= 0 && r < 6 && c >= 0 && c < 7 && this.board[r][c] === player) {
                      count++;
                      line.push([r, c]);
                    } else {
                      break;
                    }
                  }
                  
                  // Check negative direction
                  for (let i = 1; i < 4; i++) {
                    const r = row - i * dr;
                    const c = col - i * dc;
                    if (r >= 0 && r < 6 && c >= 0 && c < 7 && this.board[r][c] === player) {
                      count++;
                      line.push([r, c]);
                    } else {
                      break;
                    }
                  }
                  
                  if (count >= 4) {
                    this.winningLine = line;
                    return true;
                  }
                }
                
                return false;
              }
              
              showWin(row, col) {
                const winnerName = this.currentPlayer === 1 ? 'Spieler 1 (Gelb)' : 'Spieler 2 (Rot)';
                
                // Highlight winning pieces
                if (this.winningLine) {
                  this.winningLine.forEach(([r, c]) => {
                    const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                    if (cell) {
                      const disc = cell.querySelector('.disc');
                      if (disc) {
                        disc.classList.add('winning-disc');
                      }
                    }
                  });
                }
                
                // Update status
                const gameStatus = document.getElementById('gameStatus');
                if (gameStatus) {
                  gameStatus.textContent = `${winnerName} gewinnt!`;
                  gameStatus.className = 'font-semibold text-yellow-400';
                }
                
                console.log(`üèÜ ${winnerName} gewinnt!`);
              }
              
              showDraw() {
                const gameStatus = document.getElementById('gameStatus');
                if (gameStatus) {
                  gameStatus.textContent = 'Unentschieden!';
                  gameStatus.className = 'font-semibold text-gray-400';
                }
                
                console.log('ü§ù Unentschieden!');
              }
              
              updateScore() {
                if (this.winner === 1) {
                  this.scores.yellow++;
                } else if (this.winner === 2) {
                  this.scores.red++;
                }
                
                const yellowScore = document.getElementById('yellowScore');
                const redScore = document.getElementById('redScore');
                
                if (yellowScore) yellowScore.textContent = this.scores.yellow;
                if (redScore) redScore.textContent = this.scores.red;
              }
              
              resetScore() {
                this.scores = { yellow: 0, red: 0 };
                
                const yellowScore = document.getElementById('yellowScore');
                const redScore = document.getElementById('redScore');
                
                if (yellowScore) yellowScore.textContent = '0';
                if (redScore) redScore.textContent = '0';
                
                console.log('üîÑ Score reset');
              }
              
              undoMove() {
                if (this.gameHistory.length === 0) return false;
                
                const lastMove = this.gameHistory.pop();
                this.board = lastMove.board;
                this.currentPlayer = lastMove.player;
                this.moveCount--;
                this.gameOver = false;
                this.winner = null;
                
                // Update all cells
                for (let row = 0; row < 6; row++) {
                  for (let col = 0; col < 7; col++) {
                    const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                    if (cell) {
                      const disc = cell.querySelector('.disc');
                      if (disc) {
                        disc.classList.remove('empty', 'yellow', 'red', 'winning-disc');
                        if (this.board[row][col] === 0) {
                          disc.classList.add('empty');
                          disc.style.background = 'rgba(255, 255, 255, 0.1)';
                          disc.style.border = '1px solid rgba(255, 255, 255, 0.2)';
                          disc.style.boxShadow = 'none';
                        } else if (this.board[row][col] === 1) {
                          disc.classList.add('yellow');
                          disc.style.background = 'linear-gradient(135deg, #FFD700, #FFA000)';
                          disc.style.border = '3px solid #FF8F00';
                          disc.style.boxShadow = '0 4px 12px rgba(255, 215, 0, 0.6)';
                        } else if (this.board[row][col] === 2) {
                          disc.classList.add('red');
                          disc.style.background = 'linear-gradient(135deg, #F44336, #D32F2F)';
                          disc.style.border = '3px solid #C62828';
                          disc.style.boxShadow = '0 4px 12px rgba(244, 67, 54, 0.6)';
                        }
                      }
                    }
                  }
                }
                
                this.updateUI();
                return true;
              }
              
              resetGame() {
                this.board = Array(6).fill(null).map(() => Array(7).fill(0));
                this.currentPlayer = 1;
                this.gameOver = false;
                this.winner = null;
                this.moveCount = 0;
                this.gameHistory = [];
                this.winningLine = null;
                
                // Use BoardRenderer if available
                if (this.boardRenderer && this.boardRenderer.clearBoard) {
                  this.boardRenderer.clearBoard();
                } else {
                  // Fallback to direct DOM manipulation
                  const cells = document.querySelectorAll('.game-slot');
                  cells.forEach(cell => {
                    const disc = cell.querySelector('.disc');
                    if (disc) {
                      disc.classList.remove('yellow', 'red', 'winning-disc');
                      disc.classList.add('empty');
                      disc.style.background = 'rgba(255, 255, 255, 0.1)';
                      disc.style.border = '1px solid rgba(255, 255, 255, 0.2)';
                      disc.style.boxShadow = 'none';
                    }
                  });
                }
                
                this.updateUI();
                console.log('üîÑ New game started');
              }
              
              updateUI() {
                // Update current player indicator
                const indicator = document.getElementById('currentPlayerIndicator');
                if (indicator) {
                  const disc = indicator.querySelector('.player-disc');
                  const name = indicator.querySelector('.player-name');
                  if (disc && name) {
                    if (this.currentPlayer === 1) {
                      disc.className = 'player-disc w-8 h-8 rounded-full mr-3 bg-gradient-to-br from-yellow-400 to-yellow-600 shadow-lg';
                      name.textContent = 'Spieler 1';
                    } else {
                      disc.className = 'player-disc w-8 h-8 rounded-full mr-3 bg-gradient-to-br from-red-500 to-red-700 shadow-lg';
                      name.textContent = 'Spieler 2';
                    }
                  }
                }
                
                // Update move counter
                const moveCounter = document.getElementById('moveCounter');
                if (moveCounter) {
                  moveCounter.textContent = this.moveCount;
                }
                
                // Update game status if not game over
                if (!this.gameOver) {
                  const gameStatus = document.getElementById('gameStatus');
                  if (gameStatus) {
                    gameStatus.textContent = 'Spiel l√§uft';
                    gameStatus.className = 'font-semibold text-green-400';
                  }
                }
                
                // Update undo button
                const undoBtn = document.getElementById('undoBtn');
                if (undoBtn) {
                  undoBtn.disabled = this.gameHistory.length === 0;
                }
              }
              
              showModal(modalId) {
                const modal = document.getElementById(modalId);
                if (modal) {
                  modal.classList.remove('hidden');
                  document.body.style.overflow = 'hidden';
                }
              }
              
              hideModal(modalId) {
                const modal = document.getElementById(modalId);
                if (modal) {
                  modal.classList.add('hidden');
                  document.body.style.overflow = '';
                }
              }
              
              toggleModal(modalId) {
                const modal = document.getElementById(modalId);
                if (modal) {
                  if (modal.classList.contains('hidden')) {
                    this.showModal(modalId);
                  } else {
                    this.hideModal(modalId);
                  }
                }
              }
            }
            
          // Create and initialize Local game
          const game = new LocalConnect4Game();
          await game.init();
          
          window.game = game; // For debugging
          
          console.log('‚úÖ Local Connect4 Game initialized successfully!');
          return true;
          
        } catch (error) {
          console.error('‚ùå Local module initialization failed:', error);
          throw error;
        }
      }
      
      // EMERGENCY MINIMAL IMPLEMENTATION (SAME AS BEFORE)
      console.log('üö® DEFINING MINIMAL CONNECT4 FALLBACK...');
      
      // DIRECT MINIMAL IMPLEMENTATION - NO MODULE IMPORTS
      function initializeMinimalConnect4() {
        console.log('üîß Emergency minimal Connect4 initialization...');
        
        // Simple game state
        const gameState = {
          board: Array(6).fill(null).map(() => Array(7).fill(0)),
          currentPlayer: 1,
          gameOver: false,
          winner: null,
          moveCount: 0
        };
        
        // Create board
        const gameBoard = document.getElementById('gameBoard');
        if (gameBoard) {
          gameBoard.innerHTML = '';
          
          // Create 42 cells
          for (let row = 0; row < 6; row++) {
            for (let col = 0; col < 7; col++) {
              const cell = document.createElement('div');
              cell.className = 'game-slot relative bg-blue-500 rounded-full border-2 border-blue-700 cursor-pointer aspect-square flex items-center justify-center';
              cell.dataset.row = row;
              cell.dataset.col = col;
              
              const disc = document.createElement('div');
              disc.className = 'disc empty w-[85%] h-[85%] rounded-full';
              disc.style.background = 'rgba(255, 255, 255, 0.1)';
              disc.style.border = '1px solid rgba(255, 255, 255, 0.2)';
              
              cell.appendChild(disc);
              gameBoard.appendChild(cell);
              
              // Add click handler
              cell.addEventListener('click', () => makeMove(col));
            }
          }
          
          console.log('‚úÖ Emergency board created with 42 cells');
        }
        
        // Make move function
        function makeMove(col) {
          if (gameState.gameOver || col < 0 || col >= 7) return;
          
          // Find lowest empty row
          let targetRow = -1;
          for (let row = 5; row >= 0; row--) {
            if (gameState.board[row][col] === 0) {
              targetRow = row;
              break;
            }
          }
          
          if (targetRow === -1) return; // Column full
          
          // Make move
          gameState.board[targetRow][col] = gameState.currentPlayer;
          gameState.moveCount++;
          
          // Update visual
          const cell = document.querySelector(`[data-row="${targetRow}"][data-col="${col}"]`);
          if (cell) {
            const disc = cell.querySelector('.disc');
            if (disc) {
              disc.classList.remove('empty');
              disc.classList.add(gameState.currentPlayer === 1 ? 'yellow' : 'red');
              
              if (gameState.currentPlayer === 1) {
                disc.style.background = 'linear-gradient(135deg, #FFD700, #FFA000)';
                disc.style.border = '3px solid #FF8F00';
                disc.style.boxShadow = '0 4px 12px rgba(255, 215, 0, 0.6)';
              } else {
                disc.style.background = 'linear-gradient(135deg, #F44336, #D32F2F)';
                disc.style.border = '3px solid #C62828';
                disc.style.boxShadow = '0 4px 12px rgba(244, 67, 54, 0.6)';
              }
            }
          }
          
          // Check win
          if (checkWin(targetRow, col)) {
            gameState.gameOver = true;
            gameState.winner = gameState.currentPlayer;
            const winnerName = gameState.currentPlayer === 1 ? 'Spieler 1 (Gelb)' : 'Spieler 2 (Rot)';
            
            const statusEl = document.getElementById('gameStatus');
            if (statusEl) {
              statusEl.textContent = `${winnerName} gewinnt!`;
              statusEl.className = 'font-semibold text-yellow-400';
            }
            
            console.log(`üèÜ ${winnerName} gewinnt!`);
          } else if (gameState.moveCount === 42) {
            gameState.gameOver = true;
            gameState.winner = 0;
            
            const statusEl = document.getElementById('gameStatus');
            if (statusEl) {
              statusEl.textContent = 'Unentschieden!';
              statusEl.className = 'font-semibold text-gray-400';
            }
            
            console.log('ü§ù Unentschieden!');
          } else {
            // Switch player
            gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;
            updatePlayerIndicator();
          }
        }
        
        // Check win function
        function checkWin(row, col) {
          const player = gameState.board[row][col];
          const directions = [
            [0, 1], [1, 0], [1, 1], [1, -1]
          ];
          
          for (const [dr, dc] of directions) {
            let count = 1;
            
            // Check positive direction
            for (let i = 1; i < 4; i++) {
              const r = row + i * dr;
              const c = col + i * dc;
              if (r >= 0 && r < 6 && c >= 0 && c < 7 && gameState.board[r][c] === player) {
                count++;
              } else {
                break;
              }
            }
            
            // Check negative direction
            for (let i = 1; i < 4; i++) {
              const r = row - i * dr;
              const c = col - i * dc;
              if (r >= 0 && r < 6 && c >= 0 && c < 7 && gameState.board[r][c] === player) {
                count++;
              } else {
                break;
              }
            }
            
            if (count >= 4) return true;
          }
          
          return false;
        }
        
        // Update player indicator
        function updatePlayerIndicator() {
          const indicator = document.getElementById('currentPlayerIndicator');
          if (indicator) {
            const disc = indicator.querySelector('.player-disc');
            const name = indicator.querySelector('.player-name');
            if (disc && name) {
              if (gameState.currentPlayer === 1) {
                disc.className = 'player-disc w-8 h-8 rounded-full mr-3 bg-gradient-to-br from-yellow-400 to-yellow-600 shadow-lg';
                name.textContent = 'Spieler 1';
              } else {
                disc.className = 'player-disc w-8 h-8 rounded-full mr-3 bg-gradient-to-br from-red-500 to-red-700 shadow-lg';
                name.textContent = 'Spieler 2';
              }
            }
          }
        }
        
        // Set up new game button
        const newGameBtn = document.getElementById('newGameBtn');
        if (newGameBtn) {
          newGameBtn.addEventListener('click', () => {
            // Reset game state
            gameState.board = Array(6).fill(null).map(() => Array(7).fill(0));
            gameState.currentPlayer = 1;
            gameState.gameOver = false;
            gameState.winner = null;
            gameState.moveCount = 0;
            
            // Reset all cells
            const cells = document.querySelectorAll('.game-slot');
            cells.forEach(cell => {
              const disc = cell.querySelector('.disc');
              if (disc) {
                disc.classList.remove('yellow', 'red');
                disc.classList.add('empty');
                disc.style.background = 'rgba(255, 255, 255, 0.1)';
                disc.style.border = '1px solid rgba(255, 255, 255, 0.2)';
                disc.style.boxShadow = 'none';
              }
            });
            
            // Reset UI
            const statusEl = document.getElementById('gameStatus');
            if (statusEl) {
              statusEl.textContent = 'Spiel l√§uft';
              statusEl.className = 'font-semibold text-green-400';
            }
            
            updatePlayerIndicator();
            console.log('üîÑ New game started');
          });
        }
        
        // Initialize UI
        updatePlayerIndicator();
        
        // Make available for debugging
        window.game = {
          state: gameState,
          makeMove: makeMove,
          checkWin: checkWin
        };
        
        console.log('‚úÖ Emergency minimal Connect4 initialized successfully!');
      }
      
      // SYSTEM INITIALIZATION - LOCAL MODULES mit Error Fallback
      async function initializeConnect4System() {
        console.log('üöÄ Starting Connect4 System Initialization...');
        
        try {
          // Try local modules system
          await initializeLocalConnect4();
          console.log('‚úÖ Local Connect4 system activated successfully!');
        } catch (error) {
          console.error('‚ùå Local modules system failed:', error);
          
          // Show user-friendly error message
          showModuleError(error);
          
          // Fallback to minimal system
          console.log('üîÑ Falling back to minimal implementation...');
          initializeMinimalConnect4();
        }
      }
      
      // Show module loading error to user
      function showModuleError(error) {
        const errorDiv = document.createElement('div');
        errorDiv.style.cssText = 'position: fixed; top: 20px; right: 20px; background: rgba(244, 67, 54, 0.9); color: white; padding: 15px; border-radius: 12px; z-index: 10000; max-width: 350px; box-shadow: 0 8px 24px rgba(0,0,0,0.3); backdrop-filter: blur(10px);';
        errorDiv.innerHTML = `
          <div style="display: flex; align-items: center; margin-bottom: 8px;">
            <span style="font-size: 18px; margin-right: 8px;">‚ö†Ô∏è</span>
            <strong>Module Loading Failed</strong>
          </div>
          <p style="margin: 0; font-size: 14px; opacity: 0.9;">Using simplified version. Some features may be limited.</p>
        `;
        document.body.appendChild(errorDiv);
        
        // Auto-hide after 5 seconds
        setTimeout(() => {
          errorDiv.style.opacity = '0';
          errorDiv.style.transform = 'translateX(100%)';
          setTimeout(() => errorDiv.remove(), 300);
        }, 5000);
      }
      
      // IMMEDIATE INITIALIZATION
      document.addEventListener('DOMContentLoaded', () => {
        console.log('üö® DOM LOADED - STARTING CONNECT4 SYSTEM');
        initializeConnect4System();
      });
      
      // If DOM already loaded, run immediately
      if (document.readyState !== 'loading') {
        console.log('üö® DOM ALREADY LOADED - STARTING CONNECT4 SYSTEM NOW');
        initializeConnect4System();
      }
    </script>
    <script type="module">
      console.log('üöÄ STEP 3: Activating WASM Backend Integration...');
      
      // Import BaseGameUI from local modules
      try {
        const { BaseGameUI } = await import('./js/modules/core/BaseGameUI.js');
        console.log('‚úÖ BaseGameUI imported successfully');
        
        // Import Connect4 Config
        const { CONNECT4_UI_CONFIG, createConnect4Config } = await import('./js/connect4-config.js');
        console.log('‚úÖ Connect4 Config imported successfully');
        
        // Import BoardRenderer Component
        const { BoardRenderer } = await import('./js/components/BoardRenderer.js');
        console.log('‚úÖ BoardRenderer imported successfully');
        
        // Import WASM Backend
        const { Connect4GameBitPacked } = await import('./js/game.js');
        console.log('‚úÖ WASM Backend imported successfully');
        
        // Create a hybrid game that extends BaseGameUI with BoardRenderer + WASM
        class ModularConnect4Game extends BaseGameUI {
          constructor() {
            const config = createConnect4Config('two-player');
            
            // Initialize WASM Backend first
            this.wasmGame = new Connect4GameBitPacked();
            super(this.wasmGame, config); // Pass WASM backend to BaseGameUI
            
            // Legacy game state for compatibility
            this.board = Array(6).fill(null).map(() => Array(7).fill(0));
            this.currentPlayer = 1;
            this.gameOver = false;
            this.winner = null;
            this.moveCount = 0;
            this.gameHistory = [];
            this.scores = { yellow: 0, red: 0 };
            
            // Initialize BoardRenderer
            this.boardRenderer = null;
            
            console.log('üéÆ ModularConnect4Game created with BaseGameUI + BoardRenderer + WASM');
          }
          
          async init() {
            console.log('üîÑ Initializing modular Connect4...');
            
            // Initialize WASM Backend first
            try {
              await this.wasmGame.init();
              console.log('‚úÖ WASM Backend initialized successfully');
            } catch (error) {
              console.error('‚ùå WASM Backend initialization failed:', error);
              console.log('üîÑ Continuing with legacy game logic...');
            }
            
            // Call parent init
            await super.init();
            
            // Initialize BoardRenderer
            this.initializeBoardRenderer();
            
            // Initialize our game
            this.createBoard();
            this.setupEventListeners();
            this.updateUI();
            
            console.log('‚úÖ Modular Connect4 initialized successfully');
            return true;
          }
          
          initializeBoardRenderer() {
            const gameBoard = document.getElementById('gameBoard');
            const topCoords = document.getElementById('topCoords');
            const bottomCoords = document.getElementById('bottomCoords');
            
            if (gameBoard) {
              this.boardRenderer = new BoardRenderer(gameBoard, topCoords, bottomCoords);
              console.log('üéØ BoardRenderer initialized');
            } else {
              console.error('‚ùå GameBoard element not found for BoardRenderer');
            }
          }
          
          createBoard() {
            // Use BoardRenderer to create board
            if (this.boardRenderer) {
              const success = this.boardRenderer.initializeBoard();
              if (success) {
                this.boardRenderer.createCoordinateLabels();
                console.log('üéØ Board created using BoardRenderer');
              } else {
                console.error('‚ùå BoardRenderer initialization failed');
                this.fallbackCreateBoard();
              }
            } else {
              console.warn('‚ö†Ô∏è BoardRenderer not available, using fallback');
              this.fallbackCreateBoard();
            }
          }
          
          fallbackCreateBoard() {
            const gameBoard = document.getElementById('gameBoard');
            if (!gameBoard) {
              console.error('‚ùå Game board element not found');
              return;
            }
            
            gameBoard.innerHTML = '';
            
            // Create 42 cells (6 rows x 7 cols)
            for (let row = 0; row < 6; row++) {
              for (let col = 0; col < 7; col++) {
                const cell = document.createElement('div');
                cell.className = 'game-slot relative bg-blue-500 rounded-full border-2 border-blue-700 cursor-pointer aspect-square flex items-center justify-center';
                cell.dataset.row = row;
                cell.dataset.col = col;
                
                const disc = document.createElement('div');
                disc.className = 'disc empty w-[85%] h-[85%] rounded-full';
                
                cell.appendChild(disc);
                gameBoard.appendChild(cell);
              }
            }
            
            console.log('üéØ Fallback board created with 42 cells');
          }
          
          setupEventListeners() {
            // Board click handler
            document.getElementById('gameBoard').addEventListener('click', (e) => {
              const cell = e.target.closest('.game-slot');
              if (cell && !this.gameOver) {
                const col = parseInt(cell.dataset.col);
                this.makeMove(col);
              }
            });
            
            // Column coordinates click handler
            document.querySelectorAll('.coord').forEach((coord, index) => {
              coord.addEventListener('click', () => {
                if (!this.gameOver) {
                  this.makeMove(index);
                }
              });
            });
            
            // Button handlers
            document.getElementById('newGameBtn').addEventListener('click', () => {
              this.resetGame();
            });
            
            document.getElementById('undoBtn').addEventListener('click', () => {
              this.undoMove();
            });
            
            document.getElementById('resetScoreBtn').addEventListener('click', () => {
              this.resetScore();
            });
            
            // Modal handlers
            document.getElementById('helpBtn').addEventListener('click', () => {
              this.showModal('helpModal');
            });
            
            document.getElementById('assistanceBtn').addEventListener('click', () => {
              this.showModal('assistanceModal');
            });
            
            document.getElementById('closeHelpModal').addEventListener('click', () => {
              this.hideModal('helpModal');
            });
            
            document.getElementById('closeAssistanceModal').addEventListener('click', () => {
              this.hideModal('assistanceModal');
            });
            
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
              if (e.key >= '1' && e.key <= '7' && !this.gameOver) {
                const col = parseInt(e.key) - 1;
                this.makeMove(col);
              } else if (e.key === 'n' || e.key === 'N') {
                this.resetGame();
              } else if (e.key === 'u' || e.key === 'U') {
                this.undoMove();
              } else if (e.key === 'F1') {
                e.preventDefault();
                this.toggleModal('helpModal');
              } else if (e.key === 'F2') {
                e.preventDefault();
                this.toggleModal('assistanceModal');
              } else if (e.key === 'F3') {
                e.preventDefault();
                this.resetScore();
              } else if (e.key === 'Escape') {
                this.hideModal('helpModal');
                this.hideModal('assistanceModal');
              }
            });
            
            // Modal click outside to close
            document.getElementById('helpModal').addEventListener('click', (e) => {
              if (e.target.id === 'helpModal') {
                this.hideModal('helpModal');
              }
            });
            
            document.getElementById('assistanceModal').addEventListener('click', (e) => {
              if (e.target.id === 'assistanceModal') {
                this.hideModal('assistanceModal');
              }
            });
            
            console.log('üéÆ Event listeners set up');
          }
          
          makeMove(col) {
            if (this.gameOver || col < 0 || col >= 7) return false;
            
            // Try WASM move first
            if (this.wasmGame && this.wasmGame.initialized) {
              try {
                const moveResult = this.wasmGame.makeMove(col);
                
                // Update legacy state for UI compatibility
                this.board = moveResult.board;
                this.currentPlayer = moveResult.player === 1 ? 2 : 1; // Next player
                this.moveCount = moveResult.moveNumber;
                this.gameOver = moveResult.isGameOver;
                this.winner = moveResult.winner;
                
                // Update visual
                const targetRow = this.findMoveRow(col, moveResult.board);
                if (targetRow !== -1) {
                  this.updateCell(targetRow, col, moveResult.player);
                }
                
                // Check for win
                if (moveResult.isGameOver) {
                  if (moveResult.winner) {
                    this.showWin(targetRow, col);
                    this.updateScore();
                  } else {
                    this.showDraw();
                  }
                }
                
                this.updateUI();
                return true;
                
              } catch (error) {
                console.error('‚ùå WASM move failed:', error);
                console.log('üîÑ Falling back to legacy move logic...');
              }
            }
            
            // Legacy move logic as fallback
            return this.legacyMakeMove(col);
          }
          
          findMoveRow(col, board) {
            for (let row = 5; row >= 0; row--) {
              if (board[row][col] !== 0) {
                return row;
              }
            }
            return -1;
          }
          
          legacyMakeMove(col) {
            // Find lowest empty row in column
            let targetRow = -1;
            for (let row = 5; row >= 0; row--) {
              if (this.board[row][col] === 0) {
                targetRow = row;
                break;
              }
            }
            
            if (targetRow === -1) return false; // Column full
            
            // Save move for undo
            this.gameHistory.push({
              row: targetRow,
              col: col,
              player: this.currentPlayer,
              board: this.board.map(row => [...row])
            });
            
            // Make the move
            this.board[targetRow][col] = this.currentPlayer;
            this.moveCount++;
            
            // Update visual
            this.updateCell(targetRow, col, this.currentPlayer);
            
            // Check for win
            if (this.checkWin(targetRow, col)) {
              this.gameOver = true;
              this.winner = this.currentPlayer;
              this.showWin(targetRow, col);
              this.updateScore();
            } else if (this.moveCount === 42) {
              this.gameOver = true;
              this.winner = 0; // Draw
              this.showDraw();
            } else {
              // Switch player
              this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
            }
            
            this.updateUI();
            return true;
          }
          
          checkWin(row, col) {
            const player = this.board[row][col];
            const directions = [
              [0, 1],  // horizontal
              [1, 0],  // vertical
              [1, 1],  // diagonal /
              [1, -1]  // diagonal \
            ];
            
            for (const [dr, dc] of directions) {
              let count = 1;
              const line = [[row, col]];
              
              // Check positive direction
              for (let i = 1; i < 4; i++) {
                const r = row + i * dr;
                const c = col + i * dc;
                if (r >= 0 && r < 6 && c >= 0 && c < 7 && this.board[r][c] === player) {
                  count++;
                  line.push([r, c]);
                } else {
                  break;
                }
              }
              
              // Check negative direction
              for (let i = 1; i < 4; i++) {
                const r = row - i * dr;
                const c = col - i * dc;
                if (r >= 0 && r < 6 && c >= 0 && c < 7 && this.board[r][c] === player) {
                  count++;
                  line.push([r, c]);
                } else {
                  break;
                }
              }
              
              if (count >= 4) {
                this.winningLine = line;
                return true;
              }
            }
            
            return false;
          }
          
          updateCell(row, col, player) {
            // Use BoardRenderer if available
            if (this.boardRenderer) {
              this.boardRenderer.updateBoardVisual(row, col, player);
            } else {
              // Fallback to direct DOM manipulation
              const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
              if (cell) {
                const disc = cell.querySelector('.disc');
                if (disc) {
                  disc.classList.remove('empty', 'yellow', 'red');
                  disc.classList.add(player === 1 ? 'yellow' : 'red');
                }
              }
            }
          }
          
          showWin(row, col) {
            const winnerName = this.currentPlayer === 1 ? 'Spieler 1 (Gelb)' : 'Spieler 2 (Rot)';
            
            // Highlight winning pieces
            if (this.winningLine) {
              this.winningLine.forEach(([r, c]) => {
                const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                if (cell) {
                  const disc = cell.querySelector('.disc');
                  if (disc) {
                    disc.classList.add('winning-disc');
                  }
                }
              });
            }
            
            // Update status
            const gameStatus = document.getElementById('gameStatus');
            if (gameStatus) {
              gameStatus.textContent = `${winnerName} gewinnt!`;
              gameStatus.className = 'font-semibold text-yellow-400';
            }
            
            console.log(`üèÜ ${winnerName} gewinnt!`);
          }
          
          showDraw() {
            const gameStatus = document.getElementById('gameStatus');
            if (gameStatus) {
              gameStatus.textContent = 'Unentschieden!';
              gameStatus.className = 'font-semibold text-gray-400';
            }
            
            console.log('ü§ù Unentschieden!');
          }
          
          updateScore() {
            if (this.winner === 1) {
              this.scores.yellow++;
            } else if (this.winner === 2) {
              this.scores.red++;
            }
            
            document.getElementById('yellowScore').textContent = this.scores.yellow;
            document.getElementById('redScore').textContent = this.scores.red;
          }
          
          resetScore() {
            this.scores = { yellow: 0, red: 0 };
            document.getElementById('yellowScore').textContent = '0';
            document.getElementById('redScore').textContent = '0';
            console.log('üîÑ Score reset');
          }
          
          undoMove() {
            // Try WASM undo first
            if (this.wasmGame && this.wasmGame.initialized && this.wasmGame.canUndo()) {
              try {
                const undoResult = this.wasmGame.undoMove();
                
                // Update legacy state for UI compatibility
                this.board = undoResult.currentState.board;
                this.currentPlayer = undoResult.currentState.currentPlayer;
                this.moveCount = undoResult.currentState.moveCount;
                this.gameOver = undoResult.currentState.isGameOver;
                this.winner = undoResult.currentState.winner;
                
                // Update all cells
                this.updateBoardFromState();
                this.updateUI();
                return true;
                
              } catch (error) {
                console.error('‚ùå WASM undo failed:', error);
                console.log('üîÑ Falling back to legacy undo logic...');
              }
            }
            
            // Legacy undo logic as fallback
            return this.legacyUndoMove();
          }
          
          legacyUndoMove() {
            if (this.gameHistory.length === 0) return false;
            
            const lastMove = this.gameHistory.pop();
            this.board = lastMove.board;
            this.currentPlayer = lastMove.player;
            this.moveCount--;
            this.gameOver = false;
            this.winner = null;
            
            // Update all cells
            this.updateBoardFromState();
            this.updateUI();
            return true;
          }
          
          updateBoardFromState() {
            for (let row = 0; row < 6; row++) {
              for (let col = 0; col < 7; col++) {
                const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (cell) {
                  const disc = cell.querySelector('.disc');
                  if (disc) {
                    disc.classList.remove('empty', 'yellow', 'red', 'winning-disc');
                    if (this.board[row][col] === 0) {
                      disc.classList.add('empty');
                    } else if (this.board[row][col] === 1) {
                      disc.classList.add('yellow');
                    } else if (this.board[row][col] === 2) {
                      disc.classList.add('red');
                    }
                  }
                }
              }
            }
          }
          
          resetGame() {
            // Try WASM reset first
            if (this.wasmGame && this.wasmGame.initialized) {
              try {
                this.wasmGame.newGame();
                
                // Update legacy state for UI compatibility
                this.board = Array(6).fill(null).map(() => Array(7).fill(0));
                this.currentPlayer = 1;
                this.gameOver = false;
                this.winner = null;
                this.moveCount = 0;
                this.gameHistory = [];
                this.winningLine = null;
                
                console.log('üîÑ New game started using WASM backend');
                
              } catch (error) {
                console.error('‚ùå WASM reset failed:', error);
                console.log('üîÑ Falling back to legacy reset logic...');
              }
            } else {
              // Legacy reset logic
              this.board = Array(6).fill(null).map(() => Array(7).fill(0));
              this.currentPlayer = 1;
              this.gameOver = false;
              this.winner = null;
              this.moveCount = 0;
              this.gameHistory = [];
              this.winningLine = null;
              
              console.log('üîÑ New game started using legacy logic');
            }
            
            // Use BoardRenderer if available
            if (this.boardRenderer) {
              this.boardRenderer.clearBoard();
            } else {
              // Fallback to direct DOM manipulation
              const cells = document.querySelectorAll('.game-slot');
              cells.forEach(cell => {
                const disc = cell.querySelector('.disc');
                if (disc) {
                  disc.classList.remove('yellow', 'red', 'winning-disc');
                  disc.classList.add('empty');
                }
              });
            }
            
            this.updateUI();
          }
          
          updateUI() {
            // Update current player indicator
            const indicator = document.getElementById('currentPlayerIndicator');
            if (indicator) {
              const disc = indicator.querySelector('.player-disc');
              const name = indicator.querySelector('.player-name');
              if (disc && name) {
                if (this.currentPlayer === 1) {
                  disc.className = 'player-disc w-8 h-8 rounded-full mr-3 bg-gradient-to-br from-yellow-400 to-yellow-600 shadow-lg';
                  name.textContent = 'Spieler 1';
                } else {
                  disc.className = 'player-disc w-8 h-8 rounded-full mr-3 bg-gradient-to-br from-red-500 to-red-700 shadow-lg';
                  name.textContent = 'Spieler 2';
                }
              }
            }
            
            // Update move counter
            const moveCounter = document.getElementById('moveCounter');
            if (moveCounter) {
              moveCounter.textContent = this.moveCount;
            }
            
            // Update game status if not game over
            if (!this.gameOver) {
              const gameStatus = document.getElementById('gameStatus');
              if (gameStatus) {
                gameStatus.textContent = 'Spiel l√§uft';
                gameStatus.className = 'font-semibold text-green-400';
              }
            }
            
            // Update undo button
            const undoBtn = document.getElementById('undoBtn');
            if (undoBtn) {
              undoBtn.disabled = this.gameHistory.length === 0;
            }
          }
          
          showModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
              modal.classList.remove('hidden');
              document.body.style.overflow = 'hidden';
            }
          }
          
          hideModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
              modal.classList.add('hidden');
              document.body.style.overflow = '';
            }
          }
          
          toggleModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
              if (modal.classList.contains('hidden')) {
                this.showModal(modalId);
              } else {
                this.hideModal(modalId);
              }
            }
          }
        }
        
        // Initialize game when DOM is ready
        document.addEventListener('DOMContentLoaded', async () => {
          try {
            const game = new ModularConnect4Game();
            await game.init();
            
            window.game = game; // For debugging
            
            console.log('üéÆ STEP 3 Complete: BaseGameUI + BoardRenderer + WASM Backend activated!');
          } catch (error) {
            console.error('‚ùå STEP 3 Failed:', error);
            
            // Show error message
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = 'position: fixed; top: 20px; left: 20px; right: 20px; background: #f44336; color: white; padding: 15px; border-radius: 8px; z-index: 1000; max-width: 500px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);';
            errorDiv.textContent = `STEP 3 Error: ${error.message}`;
            document.body.appendChild(errorDiv);
            
            // FORCE EMERGENCY FALLBACK ON ANY ERROR
            console.log('üö® ACTIVATING EMERGENCY FALLBACK DUE TO INIT ERROR...');
            initializeMinimalConnect4();
          }
        });
        
      } catch (error) {
        console.error('‚ùå Failed to import modules:', error);
        
        // Fallback to minimal implementation
        console.log('üîÑ Falling back to minimal implementation...');
        
        // Show error message
        const errorDiv = document.createElement('div');
        errorDiv.style.cssText = 'position: fixed; top: 20px; left: 20px; right: 20px; background: #f44336; color: white; padding: 15px; border-radius: 8px; z-index: 1000; max-width: 500px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);';
        errorDiv.innerHTML = `
          <h3 style="margin: 0 0 10px 0;">‚ö†Ô∏è Modular Import Failed</h3>
          <p style="margin: 0 0 10px 0;"><strong>Error:</strong> ${error.message}</p>
          <p style="margin: 0; font-size: 12px; opacity: 0.9;">Using minimal implementation for now.</p>
        `;
        document.body.appendChild(errorDiv);
        
        // FORCE MINIMAL IMPLEMENTATION - CRITICAL FIX
        console.log('üö® ACTIVATING EMERGENCY FALLBACK SYSTEM...');
        initializeMinimalConnect4();
      }
      
      // Emergency Minimal Connect4 Implementation
      function initializeMinimalConnect4() {
        console.log('üîß Emergency minimal Connect4 initialization...');
        
        // Simple game state
        const gameState = {
          board: Array(6).fill(null).map(() => Array(7).fill(0)),
          currentPlayer: 1,
          gameOver: false,
          winner: null,
          moveCount: 0
        };
        
        // Create board
        const gameBoard = document.getElementById('gameBoard');
        if (gameBoard) {
          gameBoard.innerHTML = '';
          
          // Create 42 cells
          for (let row = 0; row < 6; row++) {
            for (let col = 0; col < 7; col++) {
              const cell = document.createElement('div');
              cell.className = 'game-slot relative bg-blue-500 rounded-full border-2 border-blue-700 cursor-pointer aspect-square flex items-center justify-center';
              cell.dataset.row = row;
              cell.dataset.col = col;
              
              const disc = document.createElement('div');
              disc.className = 'disc empty w-[85%] h-[85%] rounded-full';
              disc.style.background = 'rgba(255, 255, 255, 0.1)';
              disc.style.border = '1px solid rgba(255, 255, 255, 0.2)';
              
              cell.appendChild(disc);
              gameBoard.appendChild(cell);
              
              // Add click handler
              cell.addEventListener('click', () => makeMove(col));
            }
          }
          
          console.log('‚úÖ Emergency board created with 42 cells');
        }
        
        // Make move function
        function makeMove(col) {
          if (gameState.gameOver || col < 0 || col >= 7) return;
          
          // Find lowest empty row
          let targetRow = -1;
          for (let row = 5; row >= 0; row--) {
            if (gameState.board[row][col] === 0) {
              targetRow = row;
              break;
            }
          }
          
          if (targetRow === -1) return; // Column full
          
          // Make move
          gameState.board[targetRow][col] = gameState.currentPlayer;
          gameState.moveCount++;
          
          // Update visual
          const cell = document.querySelector(`[data-row="${targetRow}"][data-col="${col}"]`);
          if (cell) {
            const disc = cell.querySelector('.disc');
            if (disc) {
              disc.classList.remove('empty');
              disc.classList.add(gameState.currentPlayer === 1 ? 'yellow' : 'red');
              
              if (gameState.currentPlayer === 1) {
                disc.style.background = 'linear-gradient(135deg, #FFD700, #FFA000)';
                disc.style.border = '3px solid #FF8F00';
                disc.style.boxShadow = '0 4px 12px rgba(255, 215, 0, 0.6)';
              } else {
                disc.style.background = 'linear-gradient(135deg, #F44336, #D32F2F)';
                disc.style.border = '3px solid #C62828';
                disc.style.boxShadow = '0 4px 12px rgba(244, 67, 54, 0.6)';
              }
            }
          }
          
          // Check win
          if (checkWin(targetRow, col)) {
            gameState.gameOver = true;
            gameState.winner = gameState.currentPlayer;
            const winnerName = gameState.currentPlayer === 1 ? 'Spieler 1 (Gelb)' : 'Spieler 2 (Rot)';
            
            const statusEl = document.getElementById('gameStatus');
            if (statusEl) {
              statusEl.textContent = `${winnerName} gewinnt!`;
              statusEl.className = 'font-semibold text-yellow-400';
            }
            
            console.log(`üèÜ ${winnerName} gewinnt!`);
          } else if (gameState.moveCount === 42) {
            gameState.gameOver = true;
            gameState.winner = 0;
            
            const statusEl = document.getElementById('gameStatus');
            if (statusEl) {
              statusEl.textContent = 'Unentschieden!';
              statusEl.className = 'font-semibold text-gray-400';
            }
            
            console.log('ü§ù Unentschieden!');
          } else {
            // Switch player
            gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;
            updatePlayerIndicator();
          }
        }
        
        // Check win function
        function checkWin(row, col) {
          const player = gameState.board[row][col];
          const directions = [
            [0, 1], [1, 0], [1, 1], [1, -1]
          ];
          
          for (const [dr, dc] of directions) {
            let count = 1;
            
            // Check positive direction
            for (let i = 1; i < 4; i++) {
              const r = row + i * dr;
              const c = col + i * dc;
              if (r >= 0 && r < 6 && c >= 0 && c < 7 && gameState.board[r][c] === player) {
                count++;
              } else {
                break;
              }
            }
            
            // Check negative direction
            for (let i = 1; i < 4; i++) {
              const r = row - i * dr;
              const c = col - i * dc;
              if (r >= 0 && r < 6 && c >= 0 && c < 7 && gameState.board[r][c] === player) {
                count++;
              } else {
                break;
              }
            }
            
            if (count >= 4) return true;
          }
          
          return false;
        }
        
        // Update player indicator
        function updatePlayerIndicator() {
          const indicator = document.getElementById('currentPlayerIndicator');
          if (indicator) {
            const disc = indicator.querySelector('.player-disc');
            const name = indicator.querySelector('.player-name');
            if (disc && name) {
              if (gameState.currentPlayer === 1) {
                disc.className = 'player-disc w-8 h-8 rounded-full mr-3 bg-gradient-to-br from-yellow-400 to-yellow-600 shadow-lg';
                name.textContent = 'Spieler 1';
              } else {
                disc.className = 'player-disc w-8 h-8 rounded-full mr-3 bg-gradient-to-br from-red-500 to-red-700 shadow-lg';
                name.textContent = 'Spieler 2';
              }
            }
          }
        }
        
        // Set up new game button
        const newGameBtn = document.getElementById('newGameBtn');
        if (newGameBtn) {
          newGameBtn.addEventListener('click', () => {
            // Reset game state
            gameState.board = Array(6).fill(null).map(() => Array(7).fill(0));
            gameState.currentPlayer = 1;
            gameState.gameOver = false;
            gameState.winner = null;
            gameState.moveCount = 0;
            
            // Reset all cells
            const cells = document.querySelectorAll('.game-slot');
            cells.forEach(cell => {
              const disc = cell.querySelector('.disc');
              if (disc) {
                disc.classList.remove('yellow', 'red');
                disc.classList.add('empty');
                disc.style.background = 'rgba(255, 255, 255, 0.1)';
                disc.style.border = '1px solid rgba(255, 255, 255, 0.2)';
                disc.style.boxShadow = 'none';
              }
            });
            
            // Reset UI
            const statusEl = document.getElementById('gameStatus');
            if (statusEl) {
              statusEl.textContent = 'Spiel l√§uft';
              statusEl.className = 'font-semibold text-green-400';
            }
            
            updatePlayerIndicator();
            console.log('üîÑ New game started');
          });
        }
        
        // Initialize UI
        updatePlayerIndicator();
        
        // Make available for debugging
        window.game = {
          state: gameState,
          makeMove: makeMove,
          checkWin: checkWin
        };
        
        console.log('‚úÖ Emergency minimal Connect4 initialized successfully!');
      }
      
      // SYSTEM INITIALIZATION - CDN + FALLBACK + MINIMAL
      async function initializeConnect4System() {
        console.log('üöÄ Starting Connect4 System Initialization...');
        
        try {
          // Try modular system first (CDN + Fallback)
          const modularSuccess = await initializeModularConnect4();
          if (modularSuccess) {
            console.log('‚úÖ Modular Connect4 system activated successfully!');
            return;
          }
        } catch (error) {
          console.error('‚ùå Modular system failed completely:', error);
        }
        
        // Fallback to minimal system
        console.log('üîÑ Falling back to minimal implementation...');
        try {
          initializeMinimalConnect4();
          console.log('‚úÖ Minimal Connect4 system activated successfully!');
        } catch (error) {
          console.error('‚ùå Even minimal system failed:', error);
          
          // Last resort error message
          const errorDiv = document.createElement('div');
          errorDiv.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #f44336; color: white; padding: 20px; border-radius: 8px; z-index: 9999; text-align: center;';
          errorDiv.innerHTML = `
            <h3>‚ùå Connect4 Initialization Failed</h3>
            <p>Please refresh the page or contact support.</p>
          `;
          document.body.appendChild(errorDiv);
        }
      }
      
      // IMMEDIATE INITIALIZATION - MULTIPLE TRIGGER POINTS
      document.addEventListener('DOMContentLoaded', () => {
        console.log('üö® DOM LOADED - STARTING CONNECT4 SYSTEM');
        initializeConnect4System();
      });
      
      // If DOM already loaded, run immediately
      if (document.readyState !== 'loading') {
        console.log('üö® DOM ALREADY LOADED - STARTING CONNECT4 SYSTEM NOW');
        initializeConnect4System();
      }
      
      // Backup timer for very slow environments
      setTimeout(() => {
        const gameBoard = document.getElementById('gameBoard');
        const cells = gameBoard ? gameBoard.querySelectorAll('.game-slot') : [];
        
        if (cells.length === 0) {
          console.log('üîÑ Backup timer triggered - no cells found, forcing initialization...');
          initializeConnect4System();
        }
      }, 2000);
    </script>
  </body>
</html>