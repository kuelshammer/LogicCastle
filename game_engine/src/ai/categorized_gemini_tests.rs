/// Categorized Gemini Tests - Converting original Gemini tests to multi-move format
/// This properly categorizes tests as ExactMove, AnyValidBlock, or Strategic
/// and identifies tests that truly have multiple valid solutions

use crate::ai::gomoku_test_data::{GomokuAIMultiTestCase, GomokuTestType};

/// Get categorized Gemini test cases in multi-move format
pub fn get_categorized_gemini_test_cases() -> Vec<GomokuAIMultiTestCase> {
    vec![
        // EXACT MOVE TESTS - Critical threats with only one valid response
        
        GomokuAIMultiTestCase {
            name: "Horizontal: Block 4-in-a-row center (exact)",
            board_before: "
...............
...............
...............
...............
..W............
.......BBBB....
..W.....W......
...............
...............
...............
...............
...............
...............
...............
...............
            ",
            valid_moves: vec![(5, 11)], // Only one position blocks BBBB
            reason: "AI must block horizontal 4-in-a-row to prevent immediate loss",
            test_type: GomokuTestType::ExactMove,
        },
        
        GomokuAIMultiTestCase {
            name: "Horizontal: Block 4-in-a-row left edge (exact)",
            board_before: "
...............
...............
...............
.W.............
...............
....BBBB.......
.W......W......
...............
...............
...............
...............
...............
...............
...............
...............
            ",
            valid_moves: vec![(5, 8)], // Only one position blocks BBBB
            reason: "AI must block the only available position to prevent horizontal win",
            test_type: GomokuTestType::ExactMove,
        },
        
        GomokuAIMultiTestCase {
            name: "Vertical: Block 4-in-a-row center (exact)",
            board_before: "
...............
...............
..W............
.......B.......
.......B.......
.......B.......
.......B.......
..W.....W......
...............
...............
...............
...............
...............
...............
...............
            ",
            valid_moves: vec![(2, 7)], // Only one position blocks vertical line
            reason: "AI must block vertical 4-in-a-row threat",
            test_type: GomokuTestType::ExactMove,
        },
        
        GomokuAIMultiTestCase {
            name: "Vertical: Block 4-in-a-row edge constraint (exact)",
            board_before: "
.......B.......
.......B.......
.......B.......
.......B.......
..W............
...............
..W.....W......
...............
...............
...............
...............
...............
...............
...............
...............
            ",
            valid_moves: vec![(4, 7)], // Only one position blocks at edge
            reason: "AI must block the only available position at board edge",
            test_type: GomokuTestType::ExactMove,
        },
        
        GomokuAIMultiTestCase {
            name: "Diagonal: Block falling diagonal 4-in-a-row (exact)",
            board_before: "
...............
...............
....B..........
.....B.........
......B........
.......B.......
...............
..W............
...............
...W...........
...............
...............
........W......
...............
...............
            ",
            valid_moves: vec![(6, 8)], // Only one position blocks diagonal
            reason: "AI must block falling diagonal threat",
            test_type: GomokuTestType::ExactMove,
        },
        
        GomokuAIMultiTestCase {
            name: "Diagonal: Block rising diagonal 4-in-a-row (exact)",
            board_before: "
...............
..W............
...............
...............
.......B.......
......B........
.....B.........
....B..........
...............
...............
...............
............W..
...............
.....W.........
...............
            ",
            valid_moves: vec![(3, 8)], // Only one position blocks diagonal
            reason: "AI must block rising diagonal threat",
            test_type: GomokuTestType::ExactMove,
        },
        
        GomokuAIMultiTestCase {
            name: "Complex: Multiple threats priority (exact)",
            board_before: "
...............
...W...........
...............
.........B.....
...............
......BBBB.....
...B...........
...............
........W......
...............
.W.............
...............
........W......
...............
.....W.........
            ",
            valid_moves: vec![(5, 10)], // Must prioritize immediate 4-in-a-row
            reason: "AI must prioritize immediate 4-in-a-row threat over other considerations",
            test_type: GomokuTestType::ExactMove,
        },
        
        GomokuAIMultiTestCase {
            name: "Pattern Recognition: Hidden threat in complex position (exact)",
            board_before: "
...............
...............
...W.B.........
..BW.W.........
.B.BBBB........
...W.B.........
...............
...............
...............
...............
...............
.....W.........
...............
.....W.........
..........W....
            ",
            valid_moves: vec![(4, 7)], // Must detect hidden threat
            reason: "AI must detect threat hidden among other stones",
            test_type: GomokuTestType::ExactMove,
        },
        
        // MULTIPLE VALID BLOCKS - Open three and similar patterns
        
        GomokuAIMultiTestCase {
            name: "Open Three: Block horizontal open three (multiple valid)",
            board_before: "
...............
...............
...............
...............
...............
......BBB......
...............
...............
...............
...............
...............
.....W.........
...............
...W...........
...............
            ",
            valid_moves: vec![(5, 5), (5, 9)], // Both ends of .BBB. are valid
            reason: "AI can block open three at either end: .BBB. -> WBBB. or .BBBW",
            test_type: GomokuTestType::AnyValidBlock,
        },
        
        // STRATEGIC TESTS - Multiple good moves for fork creation
        
        GomokuAIMultiTestCase {
            name: "Fork: Create horizontal-vertical fork (strategic)",
            board_before: "
...............
...............
.......W.......
...............
....W...W......
...............
.......W.......
...............
..B............
...............
..B............
...............
..B............
...............
..B............
            ",
            valid_moves: vec![
                (4, 6),  // Create central fork
                (1, 7),  // Extend vertical threat
                (7, 7),  // Extend vertical threat
                (4, 5),  // Alternative fork position
                (4, 7)   // Alternative fork position
            ],
            reason: "AI can create fork with multiple threat vectors",
            test_type: GomokuTestType::Strategic,
        },
        
        // ADDITIONAL CATEGORIZED TESTS - Enhanced with multi-move analysis
        
        GomokuAIMultiTestCase {
            name: "Broken Three: Multiple connection options (multiple valid)",
            board_before: "
...............
...............
...............
...............
...............
.....B.B.B.....
...............
...............
...............
...............
.....W.........
...............
.....W.........
...............
...............
            ",
            valid_moves: vec![(5, 6), (5, 8)], // Fill either gap in B.B.B
            reason: "AI can connect broken three at either gap position",
            test_type: GomokuTestType::AnyValidBlock,
        },
        
        GomokuAIMultiTestCase {
            name: "Double Threat: Choose any blocking position (multiple valid)",
            board_before: "
..........W....
.....W.........
......BBB......
...............
...............
...W...........
...............
.......B.......
.......B.......
.......B.......
.......B.......
..W............
...............
..W............
.........W.....
            ",
            valid_moves: vec![
                (2, 5), (2, 9),  // Block horizontal open three
                (6, 7), (11, 7)  // Block vertical open four
            ],
            reason: "AI can choose to block either the horizontal or vertical threat",
            test_type: GomokuTestType::AnyValidBlock,
        },
        
        GomokuAIMultiTestCase {
            name: "Opening Development: Multiple strategic options (strategic)",
            board_before: "
...............
...............
...............
...............
...............
...............
.......B.......
...............
...............
...............
...............
...............
...............
...............
...............
            ",
            valid_moves: vec![
                (6, 6), (6, 8), (5, 7), (7, 7), // Adjacent positions
                (5, 6), (5, 8), (7, 6), (7, 8)  // Diagonal positions
            ],
            reason: "AI has multiple good opening moves near center stone",
            test_type: GomokuTestType::Strategic,
        },
    ]
}

/// Run all categorized Gemini tests
pub fn run_categorized_gemini_tests() -> (usize, usize, Vec<String>) {
    let test_cases = get_categorized_gemini_test_cases();
    let mut passed = 0;
    let mut failed = 0;
    let mut failures = Vec::new();
    
    for test_case in test_cases {
        match crate::ai::gomoku_test_data::test_gomoku_ai_multi_case(&test_case) {
            Ok(_) => {
                passed += 1;
                println!("✓ Categorized: {}", test_case.name);
            }
            Err(e) => {
                failed += 1;
                let failure_msg = format!("✗ Categorized: {}: {}", test_case.name, e);
                println!("{}", failure_msg);
                failures.push(failure_msg);
            }
        }
    }
    
    println!("\nCategorized Gemini Test Results: {} passed, {} failed", passed, failed);
    (passed, failed, failures)
}

/// Get test statistics by category
pub fn get_test_statistics_by_category() -> (usize, usize, usize) {
    let test_cases = get_categorized_gemini_test_cases();
    let mut exact_move_count = 0;
    let mut any_valid_block_count = 0;
    let mut strategic_count = 0;
    
    for test_case in test_cases {
        match test_case.test_type {
            GomokuTestType::ExactMove => exact_move_count += 1,
            GomokuTestType::AnyValidBlock => any_valid_block_count += 1,
            GomokuTestType::Strategic => strategic_count += 1,
        }
    }
    
    (exact_move_count, any_valid_block_count, strategic_count)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ai::gomoku_test_data::{parse_gomoku_ascii_to_boards, is_valid_gomoku_state};
    
    #[test]
    fn test_categorized_test_cases_validation() {
        let test_cases = get_categorized_gemini_test_cases();
        assert!(!test_cases.is_empty(), "Should have categorized test cases");
        
        // Validate all test cases have proper format
        for test_case in &test_cases {
            assert!(!test_case.name.is_empty(), "Test case should have name");
            assert!(!test_case.reason.is_empty(), "Test case should have reason");
            assert!(!test_case.valid_moves.is_empty(), "Test case should have valid moves");
            
            // Validate board format
            assert!(
                parse_gomoku_ascii_to_boards(test_case.board_before).is_ok(),
                "Board should be valid: {}",
                test_case.name
            );
            
            // Validate game state consistency
            assert!(
                is_valid_gomoku_state(test_case.board_before).unwrap_or(false),
                "Board should be valid game state: {}",
                test_case.name
            );
            
            // Validate move positions are on board
            for &(row, col) in &test_case.valid_moves {
                assert!(row < 15 && col < 15, "Move should be on board: {} at ({}, {})", test_case.name, row, col);
            }
        }
    }
    
    #[test]
    fn test_category_distribution() {
        let (exact_move, any_valid_block, strategic) = get_test_statistics_by_category();
        
        // Should have tests in each category
        assert!(exact_move > 0, "Should have ExactMove tests");
        assert!(any_valid_block > 0, "Should have AnyValidBlock tests");
        assert!(strategic > 0, "Should have Strategic tests");
        
        println!("Test category distribution:");
        println!("  ExactMove: {} tests", exact_move);
        println!("  AnyValidBlock: {} tests", any_valid_block);
        println!("  Strategic: {} tests", strategic);
    }
    
    #[test]
    fn test_exact_move_categories() {
        let test_cases = get_categorized_gemini_test_cases();
        
        // All ExactMove tests should have exactly one valid move
        for test_case in &test_cases {
            if test_case.test_type == GomokuTestType::ExactMove {
                assert_eq!(
                    test_case.valid_moves.len(),
                    1,
                    "ExactMove test should have exactly one valid move: {}",
                    test_case.name
                );
            }
        }
    }
    
    #[test]
    fn test_multi_move_categories() {
        let test_cases = get_categorized_gemini_test_cases();
        
        // AnyValidBlock and Strategic tests should have multiple valid moves
        for test_case in &test_cases {
            if test_case.test_type == GomokuTestType::AnyValidBlock || test_case.test_type == GomokuTestType::Strategic {
                assert!(
                    test_case.valid_moves.len() > 1,
                    "Multi-move test should have multiple valid moves: {}",
                    test_case.name
                );
            }
        }
    }
}