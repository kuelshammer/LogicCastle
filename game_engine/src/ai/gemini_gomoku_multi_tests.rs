/// Enhanced Gemini Gomoku AI Test Cases with Multiple Valid Moves
/// Addresses the issue that open threes (.BBB.) have multiple blocking positions

use crate::ai::gomoku_test_data::{GomokuAIMultiTestCase, GomokuTestType};

/// Get enhanced Gemini Gomoku AI test cases with multiple valid moves
pub fn get_gemini_gomoku_multi_test_cases() -> Vec<GomokuAIMultiTestCase> {
    vec![
        // EXACT MOVE TESTS - Only one correct answer
        GomokuAIMultiTestCase {
            name: "Horizontal: Block 4-in-a-row center (exact)",
            board_before: "
...............
...............
...............
...............
..W............
.......BBBB....
..W.....W......
...............
...............
...............
...............
...............
...............
...............
...............
            ",
            valid_moves: vec![(5, 11)], // Only one position blocks BBBB
            reason: "AI must block the only available position to prevent horizontal win",
            test_type: GomokuTestType::ExactMove,
        },
        
        GomokuAIMultiTestCase {
            name: "Vertical: Block 4-in-a-row (exact)",
            board_before: "
...............
...............
..W............
.......B.......
.......B.......
.......B.......
.......B.......
..W.....W......
...............
...............
...............
...............
...............
...............
...............
            ",
            valid_moves: vec![(2, 7)], // Only one position blocks the vertical line
            reason: "AI must block the only available position to prevent vertical win",
            test_type: GomokuTestType::ExactMove,
        },
        
        // MULTIPLE VALID BLOCKS - Open three has two blocking positions
        GomokuAIMultiTestCase {
            name: "Open Three: Block horizontal open three (multiple valid)",
            board_before: "
...............
...............
...............
...............
...............
......BBB......
...............
...............
...............
...............
...............
.....W.........
...............
...W...........
...............
            ",
            valid_moves: vec![(5, 5), (5, 9)], // Both ends of .BBB. are valid
            reason: "AI can block open three at either end: .BBB. -> WBBB. or .BBBW",
            test_type: GomokuTestType::AnyValidBlock,
        },
        
        GomokuAIMultiTestCase {
            name: "Open Three: Block vertical open three (multiple valid)",
            board_before: "
...............
...............
...............
.......B.......
.......B.......
.......B.......
...............
...............
..W............
...............
...............
..W............
...............
...............
...............
            ",
            valid_moves: vec![(3, 7), (6, 7)], // Both ends of vertical .BBB. are valid
            reason: "AI can block vertical open three at either end",
            test_type: GomokuTestType::AnyValidBlock,
        },
        
        GomokuAIMultiTestCase {
            name: "Open Three: Block diagonal open three (multiple valid)",
            board_before: "
...............
...............
...............
....B..........
.....B.........
......B........
...............
...............
..W............
...............
...............
..W............
...............
...............
...............
            ",
            valid_moves: vec![(2, 3), (6, 7)], // Both ends of diagonal .BBB. are valid
            reason: "AI can block diagonal open three at either end",
            test_type: GomokuTestType::AnyValidBlock,
        },
        
        // STRATEGIC TESTS - Multiple good moves, testing AI preference
        GomokuAIMultiTestCase {
            name: "Strategic: Opening center area preference",
            board_before: "
...............
...............
...............
...............
...............
...............
.......B.......
...............
...............
...............
...............
...............
...............
...............
...............
            ",
            valid_moves: vec![
                (6, 6), (6, 8), (5, 7), (7, 7), // Adjacent to existing stone
                (8, 6), (8, 8), (5, 6), (5, 8)  // Diagonal adjacencies
            ],
            reason: "AI should play near center and existing stones in opening",
            test_type: GomokuTestType::Strategic,
        },
        
        // COMPLEX SITUATIONS - Multiple threats, test prioritization
        GomokuAIMultiTestCase {
            name: "Complex: Two open threes - block either",
            board_before: "
...............
...............
...............
......BBB......
...............
..W............
..B............
..B............
..B............
...............
..W............
...............
..W............
...............
.W.......W.....
            ",
            valid_moves: vec![
                (3, 5), (3, 9), // Block horizontal open three
                (5, 2), (9, 2)  // Block vertical open three
            ],
            reason: "AI can block either open three - both are equally urgent",
            test_type: GomokuTestType::AnyValidBlock,
        },
        
        // BROKEN THREE - Multiple repair options
        GomokuAIMultiTestCase {
            name: "Broken Three: Multiple connection options",
            board_before: "
...............
...............
...............
...............
...............
.....B.B.B.....
...............
...............
...............
...............
.....W.........
...............
.....W.........
...............
...............
            ",
            valid_moves: vec![(5, 6), (5, 8)], // Fill either gap in B.B.B
            reason: "AI can connect broken three at either gap position",
            test_type: GomokuTestType::AnyValidBlock,
        },
        
        // DOUBLE THREAT CREATION
        GomokuAIMultiTestCase {
            name: "Create Fork: Multiple fork opportunities",
            board_before: "
...............
...............
.......W.......
...............
....W...W......
...............
.......W.......
...............
..B............
..B............
..B............
..B............
...............
...............
...............
            ",
            valid_moves: vec![(4, 6)], // Creates both horizontal and vertical threats
            reason: "AI should create fork with multiple simultaneous threats",
            test_type: GomokuTestType::ExactMove,
        },
        
        // ADDITIONAL REALISTIC SCENARIOS
        
        // Edge Case: Open Three near board edge
        GomokuAIMultiTestCase {
            name: "Edge Open Three: Multiple blocks near border",
            board_before: "
BBB............
...............
...............
...............
...............
...............
...............
...............
.....W.........
...............
...............
...............
.....W.........
...............
.....W.........
            ",
            valid_moves: vec![(0, 3)], // Only one side available due to board edge
            reason: "Open three at board edge has limited blocking options",
            test_type: GomokuTestType::ExactMove,
        },
        
        // L-Shaped Threat Pattern
        GomokuAIMultiTestCase {
            name: "L-Pattern: Multiple defensive options",
            board_before: "
...............
...............
...............
...............
...B...........
...B...........
...BBB.........
...............
.....W.........
...............
.....W.........
...............
.....W.........
...............
.....W.........
            ",
            valid_moves: vec![
                (3, 3), // Block vertical extension
                (6, 6), (6, 7)  // Block horizontal extension
            ],
            reason: "L-shaped pattern has multiple threat vectors to block",
            test_type: GomokuTestType::AnyValidBlock,
        },
        
        // Double Open Three: Force Choice
        GomokuAIMultiTestCase {
            name: "Double Open Three: Priority decision",
            board_before: "
...............
.W.............
...............
..BBB..........
...............
...............
...............
......BBB......
...............
.....W.........
...............
.....W.........
.....W.........
...............
.....W.........
            ",
            valid_moves: vec![
                (3, 1), (3, 5),  // Block first open three
                (7, 5), (7, 9)   // Block second open three
            ],
            reason: "Multiple open threes - AI can choose any blocking position",
            test_type: GomokuTestType::AnyValidBlock,
        },
        
        // Broken Four: Gap Filling Options
        GomokuAIMultiTestCase {
            name: "Broken Four: Multiple repair positions",
            board_before: "
...............
...............
...............
...............
...............
....B.BB.......
...............
...............
.....W.........
...............
.....W.........
...............
.....W.........
...............
...............
            ",
            valid_moves: vec![(5, 5), (5, 8)], // Fill either gap in B.BB pattern
            reason: "Broken four pattern can be completed at multiple positions",
            test_type: GomokuTestType::AnyValidBlock,
        },
        
        // Strategic Opening: Center Control
        GomokuAIMultiTestCase {
            name: "Opening: Center area development",
            board_before: "
...............
...............
...............
...............
...............
...............
.......B.......
...............
...............
...............
...............
...............
...............
...............
...............
            ",
            valid_moves: vec![
                (6, 6), (6, 8), (5, 7), (7, 7), // Adjacent positions
                (5, 6), (5, 8), (7, 6), (7, 8)  // Diagonal positions
            ],
            reason: "Multiple good opening moves near center stone",
            test_type: GomokuTestType::Strategic,
        },
    ]
}

/// Run all enhanced Gemini Gomoku multi-tests
pub fn run_gemini_gomoku_multi_tests() -> (usize, usize, Vec<String>) {
    let test_cases = get_gemini_gomoku_multi_test_cases();
    let mut passed = 0;
    let mut failed = 0;
    let mut failures = Vec::new();
    
    for test_case in test_cases {
        match crate::ai::gomoku_test_data::test_gomoku_ai_multi_case(&test_case) {
            Ok(_) => {
                passed += 1;
                println!("✓ Multi: {}", test_case.name);
            }
            Err(e) => {
                failed += 1;
                let failure_msg = format!("✗ Multi: {}: {}", test_case.name, e);
                println!("{}", failure_msg);
                failures.push(failure_msg);
            }
        }
    }
    
    println!("\nGemini Gomoku Multi-Test Results: {} passed, {} failed", passed, failed);
    (passed, failed, failures)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ai::gomoku_test_data::{parse_gomoku_ascii_to_boards, is_valid_gomoku_state};
    
    #[test]
    fn test_multi_test_cases_validation() {
        let test_cases = get_gemini_gomoku_multi_test_cases();
        assert!(!test_cases.is_empty(), "Should have multi test cases");
        
        // Validate all test cases have proper format
        for test_case in &test_cases {
            assert!(!test_case.name.is_empty(), "Test case should have name");
            assert!(!test_case.reason.is_empty(), "Test case should have reason");
            assert!(!test_case.valid_moves.is_empty(), "Test case should have valid moves");
            
            // Validate board format
            assert!(
                parse_gomoku_ascii_to_boards(test_case.board_before).is_ok(),
                "Board should be valid: {}",
                test_case.name
            );
            
            // Validate game state consistency
            assert!(
                is_valid_gomoku_state(test_case.board_before).unwrap_or(false),
                "Board should be valid game state: {}",
                test_case.name
            );
            
            // Validate move positions are on board
            for &(row, col) in &test_case.valid_moves {
                assert!(row < 15 && col < 15, "Move should be on board: {} at ({}, {})", test_case.name, row, col);
            }
        }
    }
    
    #[test]
    fn test_open_three_multiple_blocks() {
        // Test the classic open three scenario specifically
        let test_case = GomokuAIMultiTestCase {
            name: "Test Open Three",
            board_before: "
...............
...............
...............
...............
...............
......BBB......
...............
...............
...............
...............
...............
.....W.........
...............
...W...........
...............
            ",
            valid_moves: vec![(5, 5), (5, 9)], // Both positions should be equally valid
            reason: "Test that both ends of open three are valid blocks",
            test_type: GomokuTestType::AnyValidBlock,
        };
        
        // This should pass validation
        let result = crate::ai::gomoku_test_data::test_gomoku_ai_multi_case(&test_case);
        
        // We expect this to pass regardless of which move the AI chooses
        // (as long as it's one of the valid moves)
        match result {
            Ok(_) => println!("✓ Open three test passed - AI chose a valid blocking position"),
            Err(e) => println!("✗ Open three test failed: {}", e),
        }
    }
}