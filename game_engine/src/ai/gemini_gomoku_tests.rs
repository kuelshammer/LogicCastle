/// Enhanced Gomoku AI Test Cases - Converted from Gemini Reports
/// These tests are based on strategic scenarios from GEMINI_REPORTS but adapted
/// to our ASCII test infrastructure with proper validation

use crate::ai::gomoku_test_data::GomokuAITestCase;

/// Get enhanced Gomoku AI test cases converted from Gemini reports
/// All boards are properly validated and use correct 15x15 format
pub fn get_gemini_gomoku_test_cases() -> Vec<GomokuAITestCase> {
    vec![
        // Horizontal Threat Blocking Tests
        GomokuAITestCase {
            name: "Horizontal: Block 4-in-a-row center",
            board_before: "
...............
...............
...............
...............
..W............
.......BBBB....
..W.....W......
...............
...............
...............
...............
...............
...............
...............
...............
            ",
            board_after: "
...............
...............
...............
...............
..W............
.......BBBBW...
..W.....W......
...............
...............
...............
...............
...............
...............
...............
...............
            ",
            reason: "AI must block horizontal 4-in-a-row to prevent immediate loss",
        },
        
        GomokuAITestCase {
            name: "Horizontal: Block 4-in-a-row left edge",
            board_before: "
...............
...............
...............
.W.............
...............
....BBBB.......
.W......W......
...............
...............
...............
...............
...............
...............
...............
...............
            ",
            board_after: "
...............
...............
...............
.W.............
...............
....BBBBW......
.W......W......
...............
...............
...............
...............
...............
...............
...............
...............
            ",
            reason: "AI must block the only available position to prevent horizontal win",
        },
        
        // Vertical Threat Blocking Tests
        GomokuAITestCase {
            name: "Vertical: Block 4-in-a-row center",
            board_before: "
...............
...............
..W............
.......B.......
.......B.......
.......B.......
.......B.......
..W.....W......
...............
...............
...............
...............
...............
...............
...............
            ",
            board_after: "
...............
...............
..W.....W......
.......B.......
.......B.......
.......B.......
.......B.......
..W.....W......
...............
...............
...............
...............
...............
...............
...............
            ",
            reason: "AI must block vertical 4-in-a-row threat",
        },
        
        GomokuAITestCase {
            name: "Vertical: Block 4-in-a-row edge constraint",
            board_before: "
.......B.......
.......B.......
.......B.......
.......B.......
..W............
...............
..W.....W......
...............
...............
...............
...............
...............
...............
...............
...............
            ",
            board_after: "
.......B.......
.......B.......
.......B.......
.......B.......
..W.....W......
...............
..W.....W......
...............
...............
...............
...............
...............
...............
...............
...............
            ",
            reason: "AI must block the only available position at board edge",
        },
        
        // Diagonal Threat Blocking Tests
        GomokuAITestCase {
            name: "Diagonal: Block falling diagonal 4-in-a-row",
            board_before: "
...............
...............
....B..........
.....B.........
......B........
.......B.......
...............
..W............
...............
...W...........
...............
...............
........W......
...............
...............
            ",
            board_after: "
...............
...............
....B..........
.....B.........
......B........
.......B.......
........W......
..W............
...............
...W...........
...............
...............
........W......
...............
...............
            ",
            reason: "AI must block falling diagonal threat",
        },
        
        GomokuAITestCase {
            name: "Diagonal: Block rising diagonal 4-in-a-row",
            board_before: "
...............
..W............
...............
...............
.......B.......
......B........
.....B.........
....B..........
...............
...............
...............
............W..
...............
.....W.........
...............
            ",
            board_after: "
...............
..W............
...............
........W......
.......B.......
......B........
.....B.........
....B..........
...............
...............
...............
............W..
...............
.....W.........
...............
            ",
            reason: "AI must block rising diagonal threat",
        },
        
        // Open Three Blocking Tests
        GomokuAITestCase {
            name: "Open Three: Block horizontal open three",
            board_before: "
...............
...............
...............
...............
...............
......BBB......
...............
...............
...............
...............
...............
.....W.........
...............
...W...........
...............
            ",
            board_after: "
...............
...............
...............
...............
...............
.....WBBB......
...............
...............
...............
...............
...............
.....W.........
...............
...W...........
...............
            ",
            reason: "AI must block open three threat to prevent future 4-in-a-row",
        },
        
        // Fork Creation Tests (AI as attacker)
        GomokuAITestCase {
            name: "Fork: Create horizontal-vertical fork",
            board_before: "
...............
...............
.......W.......
...............
....W...W......
...............
.......W.......
...............
..B............
...............
..B............
...............
..B............
...............
..B............
            ",
            board_after: "
...............
...............
.......W.......
...............
....W.W.W......
...............
.......W.......
...............
..B............
...............
..B............
...............
..B............
...............
..B............
            ",
            reason: "AI should create fork with multiple threats",
        },
        
        // Complex Strategic Situations
        GomokuAITestCase {
            name: "Complex: Multiple threats priority",
            board_before: "
...............
...W...........
...............
.........B.....
...............
......BBBB.....
...B...........
...............
........W......
...............
...............
...............
........W......
...............
.....W.........
            ",
            board_after: "
...............
...W...........
...............
.........B.....
...............
......BBBBW....
...B...........
...............
........W......
...............
...............
...............
........W......
...............
.....W.........
            ",
            reason: "AI must prioritize immediate 4-in-a-row threat over other considerations",
        },
        
        GomokuAITestCase {
            name: "Pattern Recognition: Hidden threat in complex position",
            board_before: "
...............
...............
...W.B.........
..BW.W.........
.B.BBBB........
...W.B.........
...............
...............
...............
...............
...............
.....W.........
...............
.....W.........
...............
            ",
            board_after: "
...............
...............
...W.B.........
..BW.W.........
.B.BBBBW.......
...W.B.........
...............
...............
...............
...............
...............
.....W.........
...............
.....W.........
...............
            ",
            reason: "AI must detect threat hidden among other stones",
        },
    ]
}

/// Run all enhanced Gemini Gomoku tests
pub fn run_gemini_gomoku_tests() -> (usize, usize, Vec<String>) {
    let test_cases = get_gemini_gomoku_test_cases();
    let mut passed = 0;
    let mut failed = 0;
    let mut failures = Vec::new();
    
    for test_case in test_cases {
        match crate::ai::gomoku_test_data::test_gomoku_ai_case_xor(&test_case) {
            Ok(_) => {
                passed += 1;
                println!("✓ Gemini: {}", test_case.name);
            }
            Err(e) => {
                failed += 1;
                let failure_msg = format!("✗ Gemini: {}: {}", test_case.name, e);
                println!("{}", failure_msg);
                failures.push(failure_msg);
            }
        }
    }
    
    println!("\nGemini Gomoku Test Results: {} passed, {} failed", passed, failed);
    (passed, failed, failures)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ai::gomoku_test_data::{parse_gomoku_ascii_to_boards, is_valid_gomoku_state};
    
    #[test]
    fn test_gemini_test_cases_validation() {
        let test_cases = get_gemini_gomoku_test_cases();
        assert!(!test_cases.is_empty(), "Should have converted test cases");
        
        // Validate all test cases have proper format
        for test_case in &test_cases {
            assert!(!test_case.name.is_empty(), "Test case should have name");
            assert!(!test_case.reason.is_empty(), "Test case should have reason");
            
            // Validate board_before format
            assert!(
                parse_gomoku_ascii_to_boards(test_case.board_before).is_ok(),
                "Board before should be valid: {}",
                test_case.name
            );
            
            // Validate board_after format
            assert!(
                parse_gomoku_ascii_to_boards(test_case.board_after).is_ok(),
                "Board after should be valid: {}",
                test_case.name
            );
            
            // Validate game state consistency
            assert!(
                is_valid_gomoku_state(test_case.board_before).unwrap_or(false),
                "Board before should be valid game state: {}",
                test_case.name
            );
            
            assert!(
                is_valid_gomoku_state(test_case.board_after).unwrap_or(false),
                "Board after should be valid game state: {}",
                test_case.name
            );
        }
    }
    
    #[test]
    fn test_specific_gemini_horizontal_case() {
        // Test one specific case to ensure infrastructure works
        let test_case = GomokuAITestCase {
            name: "Test Horizontal Block",
            board_before: "
...............
...............
...............
...............
...............
...............
.......BBBB....
...............
...............
...............
...............
...............
...............
...............
...............
            ",
            board_after: "
...............
...............
...............
...............
...............
...............
.......BBBBW...
...............
...............
...............
...............
...............
...............
...............
...............
            ",
            reason: "Test horizontal blocking infrastructure",
        };
        
        // Should be able to extract the move correctly
        let move_result = crate::ai::gomoku_test_data::extract_gomoku_move_from_boards(
            test_case.board_before,
            test_case.board_after
        );
        
        assert!(move_result.is_ok(), "Should extract move successfully");
        let (row, col) = move_result.unwrap();
        assert_eq!((row, col), (6, 11), "Should extract correct position");
    }
    
    #[test] 
    fn test_gemini_board_state_transitions() {
        // Test that each before -> after transition is exactly one move
        let test_cases = get_gemini_gomoku_test_cases();
        
        for test_case in &test_cases {
            let (before_black, before_white) = parse_gomoku_ascii_to_boards(test_case.board_before).unwrap();
            let (after_black, after_white) = parse_gomoku_ascii_to_boards(test_case.board_after).unwrap();
            
            let before_total = before_black.count_set_bits() + before_white.count_set_bits();
            let after_total = after_black.count_set_bits() + after_white.count_set_bits();
            
            assert_eq!(
                after_total,
                before_total + 1,
                "Should have exactly one more stone in after state: {}",
                test_case.name
            );
        }
    }
}