/// Advanced Gomoku Test Scenarios - Broken Three and Fork-Prevention
/// These tests cover complex strategic situations where the AI must handle
/// multiple connection options or prevent opponent fork creation

use crate::ai::gomoku_test_data::{GomokuAIMultiTestCase, GomokuTestType};

/// Get advanced Gomoku test scenarios focusing on broken patterns and fork prevention
pub fn get_advanced_gomoku_scenarios() -> Vec<GomokuAIMultiTestCase> {
    vec![
        // BROKEN THREE SCENARIOS - Multiple ways to connect discontinuous patterns
        
        GomokuAIMultiTestCase {
            name: "Broken Three: B.B.B pattern - multiple connections",
            board_before: "
...............
...............
...............
...............
...............
.....B.B.B.....
...............
...............
...............
...............
.....W.........
...............
.....W.........
...............
...............
            ",
            valid_moves: vec![(5, 6), (5, 8)], // Fill either gap in B.B.B
            reason: "AI can connect broken three at either gap to create continuous threat",
            test_type: GomokuTestType::AnyValidBlock,
        },

        GomokuAIMultiTestCase {
            name: "Broken Three: BB.B pattern - single connection point",
            board_before: "
...............
...............
...............
...............
...............
.....BB.B......
...............
...............
...............
...............
.....W.........
...............
.....W.........
...............
...............
            ",
            valid_moves: vec![(5, 7)], // Only one gap to fill in BB.B
            reason: "AI must fill the single gap to create continuous threat",
            test_type: GomokuTestType::ExactMove,
        },

        GomokuAIMultiTestCase {
            name: "Broken Three: B..B pattern - create three-in-a-row",
            board_before: "
...............
...............
...............
...............
...............
.....B..B......
...............
...............
...............
...............
.....W.........
...............
.....W.........
...............
...............
            ",
            valid_moves: vec![(5, 6), (5, 7)], // Fill either middle position
            reason: "AI can fill either middle position to create three-in-a-row",
            test_type: GomokuTestType::AnyValidBlock,
        },

        GomokuAIMultiTestCase {
            name: "Broken Four: BBB.B pattern - critical connection",
            board_before: "
...............
...............
...............
...............
...............
.....BBB.B.....
...............
...............
...............
...............
.....W.........
...............
.....W.........
...............
..W............
            ",
            valid_moves: vec![(5, 8)], // Must fill gap to prevent immediate win threat
            reason: "AI must connect broken four to create immediate winning threat",
            test_type: GomokuTestType::ExactMove,
        },

        GomokuAIMultiTestCase {
            name: "Broken Diagonal: Multiple connection points",
            board_before: "
...............
...............
....B..........
.....W.........
......B........
...............
.......B.......
...............
...............
...............
.....W.........
...............
.....W.........
...............
...............
            ",
            valid_moves: vec![(3, 6), (5, 6)], // Connect diagonal at different points
            reason: "AI can connect broken diagonal at multiple strategic positions",
            test_type: GomokuTestType::AnyValidBlock,
        },

        // FORK-PREVENTION SCENARIOS - Stop opponent from creating multiple threats

        GomokuAIMultiTestCase {
            name: "Fork Prevention: Stop horizontal-vertical fork setup",
            board_before: "
...............
...............
...............
.......B.......
.......B.......
...BBB.........
...............
...............
...............
...............
.....W.........
...............
.....W.........
...............
..W.......W....
            ",
            valid_moves: vec![
                (5, 6),  // Block horizontal extension
                (2, 7),  // Block vertical extension
                (6, 7)   // Block vertical extension
            ],
            reason: "AI must prevent opponent from creating fork with multiple threat vectors",
            test_type: GomokuTestType::AnyValidBlock,
        },

        GomokuAIMultiTestCase {
            name: "Fork Prevention: Critical diagonal-horizontal intersection",
            board_before: "
...............
...............
....B..........
.....B.........
......BB.......
...............
...............
...............
...............
...............
.....W.........
...............
.....W.........
...............
..W............
            ",
            valid_moves: vec![(1, 7), (4, 8), (5, 6)], // Prevent multiple threat creation
            reason: "AI can prevent fork by blocking key intersection points",
            test_type: GomokuTestType::AnyValidBlock,
        },

        GomokuAIMultiTestCase {
            name: "Fork Prevention: Double open three threat",
            board_before: "
...............
.........W.....
......BBB......
...............
...............
...W...........
...B...........
...B...........
...B...........
...............
.....W.........
...............
.....W.........
...............
..W............
            ",
            valid_moves: vec![
                (2, 5), (2, 9),  // Block horizontal open three
                (5, 3), (9, 3)   // Block vertical open three
            ],
            reason: "AI must choose which open three to block when both create fork threats",
            test_type: GomokuTestType::AnyValidBlock,
        },

        // COMPLEX PATTERN RECOGNITION

        GomokuAIMultiTestCase {
            name: "Complex Pattern: L-shaped threat with multiple extensions",
            board_before: "
...............
...............
....B..........
....B..........
....BBB........
...............
...............
...............
...............
...............
.....W.........
...............
.....W.........
...............
..W.......W....
            ",
            valid_moves: vec![
                (1, 4),  // Block vertical extension
                (4, 7),  // Block horizontal extension
                (5, 4),  // Block vertical extension
                (4, 3)   // Block horizontal extension
            ],
            reason: "L-shaped pattern can be blocked at multiple strategic points",
            test_type: GomokuTestType::AnyValidBlock,
        },

        GomokuAIMultiTestCase {
            name: "Advanced Pattern: T-shaped configuration",
            board_before: "
.....W.........
...............
.......B.......
.......B.......
...BBBBB.......
...............
...............
...............
...............
...............
.....W.........
...............
.....W.........
...............
..W...W...W....
            ",
            valid_moves: vec![(4, 8)], // Only one position prevents immediate win
            reason: "T-shaped pattern creates immediate winning threat that must be blocked",
            test_type: GomokuTestType::ExactMove,
        },

        // DEFENSIVE PRIORITY SCENARIOS

        GomokuAIMultiTestCase {
            name: "Priority Decision: Multiple broken patterns",
            board_before: "
...............
..W............
......B.B......
...............
...............
...B.B.B.......
...............
...............
...............
...............
.....W.........
...............
.....W.........
...............
..W............
            ",
            valid_moves: vec![
                (2, 7),   // Connect first broken three
                (5, 4), (5, 6), (5, 8)  // Connect second broken three
            ],
            reason: "AI can choose which broken pattern to address when multiple exist",
            test_type: GomokuTestType::AnyValidBlock,
        },

        GomokuAIMultiTestCase {
            name: "Strategic Choice: Offense vs Defense balance",
            board_before: "
...............
...............
...............
.......B.......
.......B.......
.......B.......
...............
...W...........
...W...........
...W...........
...............
...............
...............
...............
...............
            ",
            valid_moves: vec![
                (2, 7), (6, 7),  // Block opponent vertical threat
                (6, 3), (10, 3)  // Extend own vertical threat
            ],
            reason: "AI can choose between blocking opponent or extending own threat",
            test_type: GomokuTestType::Strategic,
        },

        // EDGE CASE SCENARIOS

        GomokuAIMultiTestCase {
            name: "Edge Pattern: Broken three near border",
            board_before: "
B.B............
...............
...............
...............
...............
...............
...............
...............
...............
...............
.....W.........
...............
.....W.........
.B.............
..W............
            ",
            valid_moves: vec![(0, 1)], // Only one connection point due to board edge
            reason: "Broken pattern at board edge has limited connection options",
            test_type: GomokuTestType::ExactMove,
        },

        GomokuAIMultiTestCase {
            name: "Corner Pattern: Limited extension options",
            board_before: "
...............
...............
...............
...............
...............
...............
...............
...............
...............
...W...........
.....W.........
.....W.........
..........B....
...........B...
............B..
            ",
            valid_moves: vec![
                (11, 13), (14, 13),  // Extend diagonally
                (12, 9), (12, 11)    // Extend horizontally
            ],
            reason: "Corner patterns have multiple extension possibilities",
            test_type: GomokuTestType::Strategic,
        },
    ]
}

/// Run all advanced Gomoku scenario tests
pub fn run_advanced_gomoku_scenarios() -> (usize, usize, Vec<String>) {
    let test_cases = get_advanced_gomoku_scenarios();
    let mut passed = 0;
    let mut failed = 0;
    let mut failures = Vec::new();
    
    for test_case in test_cases {
        match crate::ai::gomoku_test_data::test_gomoku_ai_multi_case(&test_case) {
            Ok(_) => {
                passed += 1;
                println!("✓ Advanced: {}", test_case.name);
            }
            Err(e) => {
                failed += 1;
                let failure_msg = format!("✗ Advanced: {}: {}", test_case.name, e);
                println!("{}", failure_msg);
                failures.push(failure_msg);
            }
        }
    }
    
    println!("\nAdvanced Gomoku Scenario Results: {} passed, {} failed", passed, failed);
    (passed, failed, failures)
}

/// Get statistics by pattern type
pub fn get_advanced_scenario_statistics() -> (usize, usize, usize, usize) {
    let test_cases = get_advanced_gomoku_scenarios();
    let mut broken_pattern_count = 0;
    let mut fork_prevention_count = 0;
    let mut complex_pattern_count = 0;
    let mut edge_case_count = 0;
    
    for test_case in test_cases {
        if test_case.name.contains("Broken") {
            broken_pattern_count += 1;
        } else if test_case.name.contains("Fork Prevention") {
            fork_prevention_count += 1;
        } else if test_case.name.contains("Complex") || test_case.name.contains("Advanced") {
            complex_pattern_count += 1;
        } else if test_case.name.contains("Edge") || test_case.name.contains("Corner") {
            edge_case_count += 1;
        }
    }
    
    (broken_pattern_count, fork_prevention_count, complex_pattern_count, edge_case_count)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ai::gomoku_test_data::{parse_gomoku_ascii_to_boards, is_valid_gomoku_state};
    
    #[test]
    fn test_advanced_scenarios_validation() {
        let test_cases = get_advanced_gomoku_scenarios();
        assert!(!test_cases.is_empty(), "Should have advanced test cases");
        
        // Validate all test cases have proper format
        for test_case in &test_cases {
            assert!(!test_case.name.is_empty(), "Test case should have name");
            assert!(!test_case.reason.is_empty(), "Test case should have reason");
            assert!(!test_case.valid_moves.is_empty(), "Test case should have valid moves");
            
            // Validate board format
            assert!(
                parse_gomoku_ascii_to_boards(test_case.board_before).is_ok(),
                "Board should be valid: {}",
                test_case.name
            );
            
            // Validate game state consistency
            assert!(
                is_valid_gomoku_state(test_case.board_before).unwrap_or(false),
                "Board should be valid game state: {}",
                test_case.name
            );
            
            // Validate move positions are on board
            for &(row, col) in &test_case.valid_moves {
                assert!(row < 15 && col < 15, "Move should be on board: {} at ({}, {})", test_case.name, row, col);
            }
        }
    }
    
    #[test]
    fn test_pattern_type_distribution() {
        let (broken, fork_prevention, complex, edge) = get_advanced_scenario_statistics();
        
        println!("Advanced scenario distribution:");
        println!("  Broken Patterns: {} tests", broken);
        println!("  Fork Prevention: {} tests", fork_prevention);
        println!("  Complex Patterns: {} tests", complex);
        println!("  Edge Cases: {} tests", edge);
        
        // Should have tests in each category
        assert!(broken > 0, "Should have broken pattern tests");
        assert!(fork_prevention > 0, "Should have fork prevention tests");
        assert!(complex > 0, "Should have complex pattern tests");
        assert!(edge > 0, "Should have edge case tests");
    }
    
    #[test]
    fn test_broken_pattern_scenarios() {
        let test_cases = get_advanced_gomoku_scenarios();
        let broken_tests: Vec<_> = test_cases.iter()
            .filter(|t| t.name.contains("Broken"))
            .collect();
        
        assert!(!broken_tests.is_empty(), "Should have broken pattern tests");
        
        for test_case in broken_tests {
            // Broken pattern tests should have clear connection strategies
            assert!(
                test_case.reason.contains("connect") || test_case.reason.contains("gap") || test_case.reason.contains("fill"),
                "Broken pattern test should mention connection strategy: {}",
                test_case.name
            );
        }
    }
    
    #[test]
    fn test_fork_prevention_scenarios() {
        let test_cases = get_advanced_gomoku_scenarios();
        let fork_tests: Vec<_> = test_cases.iter()
            .filter(|t| t.name.contains("Fork Prevention"))
            .collect();
        
        assert!(!fork_tests.is_empty(), "Should have fork prevention tests");
        
        for test_case in fork_tests {
            // Fork prevention tests should mention blocking or preventing
            assert!(
                test_case.reason.contains("prevent") || test_case.reason.contains("block") || test_case.reason.contains("fork"),
                "Fork prevention test should mention blocking strategy: {}",
                test_case.name
            );
        }
    }
}